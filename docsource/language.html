<!DOCTYPE html>
<html lang="en">
<head>
<title>Semantic Authoring Markdown (SAM)</title>
<meta charset = "UTF-8">
<link rel="stylesheet" href="sam.css">
</head>
<body>
<div class="specification" lang="en">
<h1 class="title">Semantic Authoring Markdown (SAM)</h1>

<div class="introduction">
<div class="note">
<p class="p">This document is a formal description of the SAM language. It describes the formalisms behind the syntax and it may make SAM sound a lot more complex to work with than it really is. If you just want to learn how to write in SAM, see the <span class="phrase"><span class="annotation" data-annotation-type="document">SAM Quick Start</span></span>.</p>
</div>
<p class="p">Semantic Authoring Markdown (SAM) is a simplified markup for semantic authoring. Semantic authoring means writing texts that identify some part of their semantics thought embedded markup. Semantic authoring also places constraints on the author, making sure they create the content that is required. Semantic authoring allows for sophisticated validation and manipulation of content, supporting increased quality and improving the efficiency of the publishing process.</p>
<p class="p">SAM is a tale that grew in the telling. It was designed from the bottom up, not the top down, and so formalizing the language description comes after the fact. This document is a step along the way to a fully formal definition. There is not yet a full formal grammar for SAM. It is possible that the development of such a grammar could reveal ambiguities in the language definition that might require design changes in the future.</p>
<div class="section">
<h2 class="title">Why SAM?</h2>

<p class="p">Why is SAM needed? What are the limits of current semantic authoring solutions? The core of a semantic authoring solution is a markup language. There are, broadly, two kinds of markup languages: general and lightweight. Lightweight markup languages are easier to use, but less capable. <span class="phrase"><a href=https://en.wikipedia.org/wiki/XML class="link">XML</a></span> is the only general languages in common use today (thought SGML is also still in use). There are many lightweight markup languages. The best known is Markdown.</p>
<p class="p">The key issue for real semantic authoring is extensibility: the ability to specify your own semantics. (To create new tag that are specific to what you are writing about.)</p>
<p class="p">Current lightweight markup languages have fixed semantics with little or no extensibility. Where extensibility exists, it generally requires coding extensions to the parser.</p>
<p class="p">XML supports extensibility through schemas. But the price it pays for this is an abstract data model and a verbose syntax. Writing and editing in XML is cumbersome, even with a dedicated XML editor (and dedicated XML editors can be expensive). And while XML is intended for doing structured writing, in practice it tends to hide the structure of the content either behind a WYSIWYG editing interface or verbose markup.</p>
<p class="p">SAM attempts to bridge these two worlds, providing a lightweight syntax that is easy to read, write, and edit, and which makes the structure of the content clear and explicit. SAM is also designed to be extensible and to support the specification of new tags through a schema. (Currently the SAM Parser uses an XML schema language to validate the output XML, but a true SAM schema language is planned.)</p>
<p class="p">Most lightweight markup languages provide a fixed set of document structures with little or no extensibility. XML provides no document structures by default and makes you specify everything in a schema. SAM defines a limited set of core text structures such as paragraph and lists and then leaves it to you to specify the semantic structures that contain the text.</p>
<p class="p">It is important to note that SAM is not designed as a language for text representation. That is, it is not a language designed for taking an existing text, and, without violence to that text, adding metadata to explicate its meaning or structure. For that you need a form of markup with the ability to clearly delineate in-band and out-of-band data. XML provides this by consigning in-band data (the text of the document) to the textual content of elements, and out-of-band (metadata describing the document) to attributes. SAM defines a few preset management attributes but provided no facility for creating new ones. Any additional metadata you want to add to a block, for instance, has to take the form or fields. This muddies the distinction between in-band and out-of-band information. For content creation, this is entirely appropriate, and the whole element/attribute distinction is tedious and confusing. If you are looking for a markup language that is designed so that you can simply remove the markup and be left with the original document, SAM is not the right choice.</p>
</div>
<div class="section">
<h2 class="title">Processing model</h2>

<p class="p">SAM is a cross between an abstract or meta language like XML and a concrete language like MarkDown. XML does not describe the semantics of any of the tagging languages you base on it. The XML parser does not implement any markup semantics. Implementing semantics is left to the application layer -- another program or set of program that process the output of the parser. In many XML-based tool chains, the application layer is written in XSLT. Markdown describes the entire semantics of the language. The Markdown processor executes the entire semantics of the language, producing HTML output directly from Markdown. It does not require a separate application layer.</p>
<p class="p">SAM follows the XML model. The SAM parser simply reads the SAM markup and extracts its structures. It does not interpret the semantics of the document, but leaves that to the application layer.</p>
<p class="p">A SAM parser may make the structure of a SAM document available to the applications layer in different ways. It can expose the structure via an API and/or it may output an XML representation of the structure of the SAM document.</p>
</div>
<div class="section">
<h2 class="title">Semantics</h2>

<p class="p">While the SAM parser does not act on the semantics of the document, deferring that to the application layer, it contains concrete markup which the writer is entitled to expect will be processed in a particular way. These are the intended semantics of SAM structures. The application layer is expected to honor and implement the semantics of SAM markup.</p>
<p class="p">A lot of SAM's concrete markup is simply shortcuts for common writing structures like lists. The exact same structures could be created using blocks, fields, and paragraphs, and you can create variant structures (other types of lists, for example) using these standard components. However, some of SAM's concrete markup expresses a particular view about markup language design. For example, it use of annotations and citations expresses a particular view about how text inside paragraphs should be marked up. Since SAM does not provide other facilities to create markup in paragraphs, it may not be suitable for expressing all types of markup language design. SAM is not, and is not intended to be, a full replacement for XML.</p>
</div>
<div class="section">
<h2 class="title">SAM Structure</h2>

<p class="p">Like all other markup languages, a SAM document is essentially a set a set of nested blocks of various types. In concrete markup languages like markdown there are a fixed set of block types, each with a specific meaning, and each with a corresponding piece of syntax that allows the parser to identify them. In an abstract markup language like XML, there are a few abstract block types that have no inherent meaning, but can be named so that a processing application can attach meaning to the name in specific markup languages. Thus a paragraph is represented with a <code class="code">&lt;p&gt;</code> element in HTML but by a <code class="code">&lt;para&gt;</code> element in DocBook.</p>
<p class="p">As a hybrid language, SAM has a set of concrete block types, each with its own semantics and syntax, and a set of abstract nameable block types that can be used to define additional semantics for specific SAM-based markup languages. Thus in SAM a <span class="phrase">paragraph</span> is always created as a block of text, but you can create named blocks to capture things like <code class="code">author-name:</code>.</p>
<p class="p">Blocks may contain flows. A flow is a data value, the contents of a block, but a flow can also contain other structures. This is also a common feature of document markup languages. In HTML, for instance, you can have an <code class="code">&lt;a&gt;</code> element in the middle of a paragraph to create a link. XML-based languages, including HTML, use elements for structures within a flow (creating something called mixed content). In SAM, structures within a flow are distinct from blocks and have a different syntax.</p>
<p class="p">Four kinds of structures can exist in a flow, a <span class="phrase">phrase</span>, an <span class="phrase">insert</span>, and a <span class="phrase">citation</span>. However, a <span class="phrase">phrase</span> can be annotated to indicate its semantics, which makes <span class="phrase">phrase</span>s an extensible feature of SAM.</p>
<p class="p">The following example shows a <span class="phrase">paragraph</span> with two annotated <span class="phrase">phrase</span>s.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In {Rio Bravo}(movie), {the Duke}(actor "John Wayne" (SAG)) plays a union colonel.
</code></pre>
</div>
<div class="section">
<h2 class="title">SAM Syntax</h2>

<p class="p">Syntactically, SAM takes its cues from YAML and Python (for displaying overall structure), from Markdown (for displaying text structures) and from common English usage (for displaying annotations.) In contrast to some of the richer lightweight markup languages, it tries to minimize the use of exotic forms of punctuation to delineate structures.</p>
<p class="p">The intention is that an author writing in SAM should feel no need to use a visual editor, but should work directly in raw SAM (albeit with editor-supplied syntax coloring if desired). A SAM document should be a very natural read.</p>
<p class="p">SAM is not designed to be a full replacement for XML. It is far less general, because of its use of predefined syntax for common text structures such as lists and paragraphs, and it has very limited support for attributes. Basically, each structure has a fixed set of attributes available. There is no extensibility for attributes. This is essential to maintain the readability of SAM sources, but it limits certain styles of markup design.</p>
<p class="p">In particular, SAM is designed to support a declarative approach to semantic authoring meaning that it is designed to express declarations about the structure of the document and the meaning of the text, rather than to embed management and processing information into the source, a practice common in many structured authoring languages.</p>
<p class="p">Document-oriented markup languages such as reStructuredText and Markdown tend to be very flat in structure. One things follows another. There is rarely a case where one thing is inside another. For example, these languages use heading levels, but don't delineate sections of the document. More semantically rich languages tend to be more hierarchical, with one structure inside another. For example, a document might be divided into sections with title and paragraph elements inside a section. This means that you need to show which structures are inside others and where the containing structure ends.</p>
<p class="p">XML does this by having an explicit end tag for every element. A large part of the verbosity of XML comes from its requirement to close every element tag. Many programming languages, which similarly have to express nested structures, use some form of brackets to delineate each structure. Python is an exception to this. It uses indentation to express the relationship between structures. This is a far more natural way for writers to express the subordination of elements -- one that is sometimes also used in published works. SAM uses this approach and avoids the use of end tags entirely.</p>
<p class="p">SAM syntax defines the following structures:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">named block</dt>
<dd class="ll.li.item"><p class="p">Named blocks are structures that contain other structures. For instance, a section is a block. Blocks must have names. Named blocks (and named fields) are how you introduce new structures into a SAM document. Named blocks may be referred to a "blocks" in this document, but all of SAMs concrete block types are also blocks.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">field</dt>
<dd class="ll.li.item"><p class="p">Fields are named blocks that contain individual values. For instance, the date a document  is usually a field.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">flow</dt>
<dd class="ll.li.item"><p class="p">A flow is a string of text. All text content in a SAM document constitutes a flow. A <span class="phrase">paragraph</span> is a flow. The <span class="phrase">value</span> of a field is a flow. A <span class="phrase">title</span> is a flow. Etc. Flows can contain <span class="phrase">phrases</span>, <span class="phrase">citations</span>, and <span class="phrase">inserts</span>.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">paragraph</dt>
<dd class="ll.li.item"><p class="p">A paragraph is a continuous block of text across one or more contiguous lines. The content of a paragraph is a <span class="phrase">flow</span>.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">phrase</dt>
<dd class="ll.li.item"><p class="p">A phrase is a string of characters in a flow. You use a phrase when you want to attach an annotation or a citation to a string of text.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">string</dt>
<dd class="ll.li.item"><p class="p">Strings are named pieces of text that can be included by reference in other parts of a document or in other documents.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">annotation</dt>
<dd class="ll.li.item"><p class="p">Annotations are metadata attached to a phrase.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">attributes</dt>
<dd class="ll.li.item"><p class="p">Attributes are metadata attached to a block. There are a very limited set of attributes with specific rules for where they can appear. For most of the purposes for which you would use attributes in XML, you should use fields in SAM.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">block insertion</dt>
<dd class="ll.li.item"><p class="p">Block insertions are an instruction to the application layer in content from an internal or external source at the block level.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">flow insertion</dt>
<dd class="ll.li.item"><p class="p">Flow insertions are an instruction to the application layer in content from an internal or external source at the flow level (that is, inside a flow).</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">citations</dt>
<dd class="ll.li.item"><p class="p">Citations are references to other works or structures.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">include</dt>
<dd class="ll.li.item"><p class="p">You can include one SAM file in another.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">ordered list</dt>
<dd class="ll.li.item"><p class="p">An ordered list is as list in which the order of the items is meaningful. An ordered list is any sequence of one or more ordered list items.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">unordered list</dt>
<dd class="ll.li.item"><p class="p">An unordered list is a list in which the order of the items is not meaningful (as least as far as markup semantics is concerned). A unordered list is any sequence of one or more unordered list items.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">labeled list</dt>
<dd class="ll.li.item"><p class="p">A labeled list is a list in which each item has a label (rather than a bullet or a number). A labeled list is an sequence of one or more labeled list items. A labeled list item consists of a label and a single paragraph.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">line</dt>
<dd class="ll.li.item"><p class="p">A line is a single line of text, as in a poem, with a fixed line end. The contents of a line is a <span class="phrase">flow</span>.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">record set</dt>
<dd class="ll.li.item"><p class="p">A record set is a simple database table with named columns. It allows you to capture tabular data at a semantic level rather than at the presentation level of a table.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">grid</dt>
<dd class="ll.li.item"><p class="p">A grid is a simple table-like layout structure.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">fragment</dt>
<dd class="ll.li.item"><p class="p">Fragments are sections of a documents (potentially larger than a single paragraph) that can be included by reference in other parts of a document or in other documents. Strings used in a fragment can be redefined when a fragment is reused, allowing you to vary the text of the fragment when it is used in different places. (Note that this is describes the <span class="phrase">presumed semantics</span> of fragments. Implementation of these semantics is up to the application layer.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">comment</dt>
<dd class="ll.li.item"><p class="p">A comment on the SAM markup file itself, as opposed to a comment on the document. For comments on the document, use remark</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">remark</dt>
<dd class="ll.li.item"><p class="p">A remark is a comment on the text of the document, intended for editorial purposes. It must be attributed to a specific author.</p>
</dd>
</div>
</dl>
</div>
<div class="section" id="nametoken">
<h2 class="title">Name tokens</h2>

<p class="p">Several things in SAM have names. These names must be valid name tokens. A name token in a SAM document must be a valid XML local name. This is to allow ease of integration with XML tools and languages and for a straightforwards serialization of SAM documents to XML.</p>
</div>
<div class="section" data-name="name-like-string">
<h2 class="title">Name-like string</h2>

<p class="p">A name like string is a string that looks like a name. Name-like strings are used in parsing SAM files to detect the intention of the author to create a name. Not all name-like-strings are valid names. If the parser sees a name-like-string that is not a valid name, it reports an error.</p>
<p class="p">The reason for recognizing name-like-strings rather than only recognizing valid names is that it enables the parser to catch cases where the writer probably intended to create a name but failed to create a valid name.</p>
<p class="p">By recognizing name-like-strings the parser is able to report an errors on these dubious cases, which reduce the likelihood or misinterpreting the author's intent. In the case where the name-like-string is indeed intended to be interpreted as plain text, the writer can ensure it is interpreted as such by escaping the concluding colon with a backslash.</p>
<p class="p">However, the definition of a name-like-string can't interfere with the recognition of other SAM structures. Therefore name-like-strings don't include characters that might be mistaken for SAM markup.</p>
<p class="p">The current definition of a name-like-string is as follows, but this is subject to change:</p>
<pre class="codeblock" data-language="re"><code class="codeblock" data-language="re">(?P&lt;name&gt;\w[^\s`]*?) 
</code></pre>
</div>
<div class="section" data-name="syntax">
<h2 class="title">Syntax</h2>

<p class="p">A <span class="phrase">block</span> in SAM is formed by starting a line with a name followed by a colon:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">description:
    This is the content of a block named "description".
</code></pre>
<p class="p">Structures in SAM can contain other structures. The hierarchy of structures in SAM is defined by indentation. In the example above, the paragraph structure is inside the block named description because it is indented under it.</p>
</div>
<div class="section" data-name="SOM">
<h2 class="title">SAM Object Model</h2>

<p class="p">The SAM Object Model is a way of representing the structure of a SAM document as a data structure to a computer program. The SAM object model is a way for program to access a SAM document in a standard way. Unless you are concerned with writing programs to access the SAM Object Model you can ignore all references to it in this document. The SAM Object model is the model implemented by the current SAM parser, which is written in Python. However, SAM parsers are not required to implement the SAM Object Model.</p>
<p class="p">The other way for applications to access the structure of is by serializing it to XML. This is the only require access method for parsers to implement.</p>
<p class="p">Like the language itself, the SOM is a tale that grew in the telling. In the absence of a full formal grammar for SAM, the object model must be considered provisional. It should be considered a less stable interface to a SAM document than the canonical XML serialization.</p>
</div>
<div class="section" data-name="parser">
<h2 class="title">Parsing</h2>

<p class="p">A SAM document may be interpreted by a SAM parser to form an object tree in memory, which can include the <span class="phrase">SAM object model</span> or any standardized XML representation such as SAX or DOM. In these cases, the DOM or SAX interface should represent the standard XML serialization, or an optional variant of that serialization, not the SOM. A SAM parser must offer the option of serializing the document as XML. A SAM parser may offer various methods of serializing XML, but it must default to the serialization described in this document.</p>
</div>
</div>
<div class="structures">
<p class="p">The following is a list of the structures of a SAM document.</p>
<div class="structure" data-name="declaration">
<h2 class="title">Declaration</h2>

<p class="p">A SAM file may start with one or more declarations. A declarations gives the SAM parser information it needs to correctly parse the file. Declarations do not become part of the output.</p>
<div class="syntax">
<p class="p">Declarations must come before all other content. A <span class="phrase"><span class="annotation" data-annotation-type="structure">declaration</span></span> is created by a line beginning with  an exclamation mark followed by an declaration type followed by a colon.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">!namespace: http://spfeopentoolkit.org/sam/ns/tests
</code></pre>
</div>
<div class="attributes">
<p class="p">Declarations cannot take attributes.</p>
</div>
<div class="semantics">
<p class="p">A declaration is an instruction to the parser on how to interpret the SAM document. Declarations are not part of the content of the document described by the SAM markup. Rather, they describe the markup itself.</p>
<p class="p">The following declarations are supported:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">namespace</dt>
<dd class="ll.li.item"><p class="p">Sets the namespace for the entire SAM document. You cannot assign namespaces to individual structures in the text of a SAM document like you can in XML. When schema support is available, you will be able to assign individual elements to namespaces in the schema schema.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">annotation-lookup</dt>
<dd class="ll.li.item"><p class="p">Sets the <span class="phrase"><span class="annotation" data-annotation-type="feature">annotation lookup</span></span> mode for the document. The options are:</p>
<ul class="ul">
<li class="li">
<p class="p"><span class="phrase"><b class="bold">on</b></span> Annotation lookup is performed in a case insensitive manner.</p>
</li>
<li class="li">
<p class="p"><span class="phrase"><b class="bold">off</b></span> Annotation lookup is not performed.</p>
</li>
<li class="li">
<p class="p"><span class="phrase"><b class="bold">case sensitive</b></span> Annotation lookup is performed in a case sensitive manner.</p>
</li>
<li class="li">
<p class="p"><span class="phrase"><b class="bold">case insensitive</b></span> (default) Annotation lookup is performed in a case insensitive manner.</p>
</li>
<li class="li">
<p class="p">&lt;custom&gt; Annotation lookup is performed using a custom algorithm supported by a user-supplied extension to the parser.</p>
</li>
</ul>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">smart-quotes</dt>
<dd class="ll.li.item"><p class="p">Set the smart quotes processing mode for the parser. The options are:</p>
<ul class="ul">
<li class="li">
<p class="p"><span class="phrase"><b class="bold">on</b></span> Smart quotes processing is performed using the default rules.</p>
</li>
<li class="li">
<p class="p"><span class="phrase"><b class="bold">off</b></span> (default) Smart quotes processing is not performed.</p>
</li>
<li class="li">
<p class="p">&lt;custom&gt; Smart quotes processing is performed using a custom rule set provided by the parser. The default parser supports this via an XML file which is specified on the command line using the -sq option. Other parsers are free to support smart quotes or not, and to support custom smart quotes rules or not using a mechanism of their choice.</p>
</li>
</ul>
</dd>
</div>
</dl>
</div>
<div class="xml-serialization">
<p class="p">The namespace declaration causes the namespace of a document to be set to the specified namespace. This will result in the appropriate namespace declaration in the serialized XML file. A parser may handle namespace prefixes in any way it sees fit.</p>
</div>
<div class="html-serialization">
<p class="p">None. If a namespace declaration is used, it will not be included in the HTML serialization.</p>
</div>
<div class="SOM">
<p class="p">The namespace declaration is used to update the namespace property of all blocks. In future, the namespace property of blocks may be set by the schema.</p>
<div class="future">
<p class="p">The schema declaration specifies the location of a schema file. The location will be processed through an XML catalog if one is specified to the parser. If a schema is specified, the namespace declaration is ignored and namespaces are assigned per the schema. A schema may assign different elements to different namespaces.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">!schema: http://spfeopentoolkit.org/schemas/think-plan-do-topic.sams
</code></pre>
</div>
</div>
</div>
<div class="structure" data-name="root">
<h2 class="title">Root</h2>

<p class="p">Every SAM document has a root which contains the entire content of the document. The root can contain a single block which is the parent of all other blocks in the document. This block is called the <span class="phrase">document block</span>.</p>
<div class="syntax">
<p class="p">The <span class="phrase">root</span> had no syntax of its own. It is an implicit container for the contents of the file.</p>
</div>
<div class="attributes">
<p class="p">The root cannot take attributes.</p>
</div>
<div class="semantics">
<p class="p">None. The root is just a container.</p>
</div>
<div class="model">
<p class="p">The <span class="phrase">root</span> can contain the following, in order:</p>
<ul class="ul">
<li class="li">
<p class="p">One or more <span class="phrase">declaratiom</span>s.</p>
</li>
<li class="li">
<p class="p">One of more <span class="phrase">comment</span>s, <span class="phrase">remark</span>s, or <span class="phrase">string definition</span>s.</p>
</li>
<li class="li">
<p class="p">The <span class="phrase">root</span> block.</p>
</li>
<li class="li">
<p class="p">One of more <span class="phrase">comment</span>s, or <span class="phrase">remark</span>s.</p>
</li>
</ul>
</div>
<div class="xml-serialization">
<p class="p">The XML declaration is output as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">The HTML header is output as follows:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;title&gt;SAM Parser Tests&lt;/title&gt;
&lt;meta charset = "UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">The <span class="phrase">root</span> is represented by a <span class="phrase"><span class="annotation" data-annotation-type="SOM_object">Root</span></span> object that is created automatically by the parser when parsing starts.</p>
<p class="p">All <span class="phrase">declarations</span>, <span class="phrase">comments</span>, <span class="phrase">remarks</span>, and <span class="phrase">string definitions</span> prior to the document block, and the document block itself, are children of the <span class="phrase"><span class="annotation" data-annotation-type="SOM_object">Root</span></span> object.</p>
<p class="p">Note that the SOM <span class="phrase"><span class="annotation" data-annotation-type="SOM_object">Root</span></span> object is not the same thing as the <span class="phrase">document block</span>. The <span class="phrase"><span class="annotation" data-annotation-type="SOM_object">Root</span></span> object is a container for all the structures declared at column zero in the SAM document. The <span class="phrase">document block</span> is the only <span class="phrase">block structure</span> permitted as a direct child of the <span class="phrase"><span class="annotation" data-annotation-type="SOM_object">Root</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="field">
<h2 class="title">Field</h2>

<p class="p">A field is named container with a single value.</p>
<div class="syntax">
<p class="p">A block is indicated by a string consisting of:</p>
<ul class="ul">
<li class="li">
<p class="p">the appropriate indent for its position in the document structure</p>
</li>
<li class="li">
<p class="p">the field name</p>
</li>
<li class="li">
<p class="p">a colon</p>
</li>
<li class="li">
<p class="p"><span class="phrase">attributes</span>, if any</p>
</li>
<li class="li">
<p class="p">at least one space</p>
</li>
<li class="li">
<p class="p">the field value</p>
</li>
<li class="li">
<p class="p">a line end</p>
</li>
</ul>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">name: Fred Flintstone
address:(?foo) Bedrock
era: BC
</code></pre>
<p class="p">The name of a <span class="phrase">field</span> must be a valid <span class="phrase">SAM name</span>.</p>
<p class="p">The value of a field is a <span class="phrase">flow</span>, meaning it can contain <span class="phrase">phrases</span>, <span class="phrase">decorations</span>, <span class="phrase">annotations</span>, and <span class="phrase">citations</span>.</p>
</div>
<div class="attributes">
<p class="p">A field can take the <span class="phrase">standard attributes</span>.</p>
</div>
<div class="semantics">
<p class="p">A <span class="phrase">field</span> is essentially a way of creating a key-value pair in a document.</p>
</div>
<div class="xml-serialization">
<p class="p">A field is serialized as an XML element. The field content is the data content of the XML element. The name of the XML element matches the name of the field. Thus the example above would be serialized as:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;name&gt;Fred Flintstone&lt;/name&gt;
&lt;address&gt;Bedrock&lt;/address&gt;
&lt;era&gt;BC&lt;/era&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">A field is serialized as an HTML <code class="code">div</code> element with the field name given as the value of the <code class="code">class</code> attribute:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;div class="name"&gt;Fred Flintstone&lt;/div&gt;
&lt;div class="address"&gt;Bedrock&lt;/div&gt;
&lt;div class="era"&gt;BC&lt;/div&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A <span class="phrase">field</span> is represented by a <span class="phrase">Block</span> object. The only difference between a <span class="phrase">block</span> and a <span class="phrase">field</span> is whether it has children. If it has children, it is a <span class="phrase">block</span>. If not, it is a <span class="phrase">field</span>.</p>
<p class="p">This design is mostly to make parsing easier. When we see a <span class="phrase">field</span> definition in a file we can't tell without looking ahead whether it is going to have children or not. Therefore we treat it as a <span class="phrase">block</span>. The difference between a <span class="phrase">field</span> and a <span class="phrase">block</span> really only occurs on serialization, where the content of a <span class="phrase">field</span> is simply its text value, whereas the content of a <span class="phrase">block</span> is treated as a title and output as a <code class="code">&lt;title&gt;</code> element.</p>
<p class="p">Programs accessing the <span class="phrase">SOM</span> directly should note that the value of a <span class="phrase">block</span> should be treated as the title of that <span class="phrase">block</span>.</p>
<p class="p">The value of a <span class="phrase">field</span> is contained in a <span class="phrase">Flow</span> object.</p>
</div>
</div>
<div class="structure" data-name="block">
<h2 class="title">Block</h2>

<p class="p">A <span class="phrase">block</span> is a named container for other structures. <span class="phrase">Blocks</span> and <span class="phrase">fields</span> are the extensible structures of a <span class="phrase">SAM</span> document that allow you to create a document with specific semantics in any of the <span class="phrase">structured writing domains</span>.</p>
<p class="p">Like a <span class="phrase">field</span>, a <span class="phrase">block</span> can have a value. However, a block can also have children. A block is simply a field with children. (Or you could equally say that a field is a block without children.)</p>
<p class="p">Blocks are used to model large document structures such as sections. The value of the block is treated as the title of the section.</p>
<div class="syntax">
<p class="p">A block is syntactically identical to a <span class="phrase">field</span>. It is distinguished from a field based on whether or not it has children. The children of a block are any structures following the block header that are indented more than the block header.</p>
<p class="p">The following example defines a block named <code class="code">movie-review</code>. It is a block because it has children. Its children are the field <code class="code">movie</code> and the block <code class="code">stars</code>:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">movie-review: Wayne shines in Rio Bravo
    movie: Rio Bravo
    stars:
        star: John Wayne
</code></pre>
<p class="p">The <code class="code">movie-review</code> block as a value, <code class="code">Wayne shines in Rio Bravo' which will be treated as the title of the block on serialization. The </code>stars` block does not have a value. Its function is to act as a container for the list of stars. (As part of the regular structure of a movie review, the list of stars would likely be assigned a title during output processing, but it does not need one in the source.)</p>
</div>
<div class="attributes">
<p class="p">A block can take the <span class="phrase">standard attributes</span>.</p>
</div>
<div class="semantics">
<p class="p">The value of a <span class="phrase">block</span> is treated as the title of a the block of a <span class="phrase">block</span>, and will be serialized as such.</p>
<p class="p">Structurally, the title of a <span class="phrase">block</span> is its value, in just the same way that the content of a field is its value.</p>
</div>
<div class="xml-serialization">
<p class="p">The SAM markup above would be serialized to XML as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;movie-review&gt;
&lt;title&gt;Wayne shines in Rio Bravo&lt;/title&gt;
&lt;movie&gt;Rio Bravo&lt;/movie&gt;
&lt;stars&gt;
&lt;star&gt;John Wayne&lt;/star&gt;
&lt;/stars&gt;
&lt;/movie-review&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">A block is serialized to HTML as a <code class="code">div</code> element with the <code class="code">class</code> attribute set to the name of the block. The block title is output as an HTML heading element with the heading number calculated based on its place in the hierarchy of the document structure. Thus the SAM markup above would be serialized to HTML as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;div class="movie-review"&gt;
&lt;h1 class="title"&gt;Wayne shines in Rio Bravo&lt;/h1&gt;
&lt;div class="movie"&gt;Rio Bravo&lt;/div&gt;
&lt;div class="stars"&gt;
&lt;div class="star"&gt;John Wayne&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">The representation of a block in the <span class="phrase">SOM</span> is identical to the representation of a field. A block is distinguished from a field in the SOM by whether or not it has children.</p>
</div>
</div>
<div class="structure" data-name="document-block">
<h2 class="title">Document block</h2>

<p class="p">The <span class="phrase">document block</span> is the first structure declared in the document after any <span class="phrase"><span class="annotation" data-annotation-type="structure">declaration</span></span>s, <span class="phrase">comment</span>s, <span class="phrase">remark</span>s or <span class="phrase">string definition</span>s. It is the container for all other blocks in the document.</p>
<p class="p">Any type of <span class="phrase">block</span> can be the <span class="phrase">document block</span>, including concrete structures such as paragraphs and lists. However, choosing a structure other than a named <span class="phrase">block</span> as the document block will be extremely limiting, as most concrete structure types allow for little or no nesting of other blocks. For instance, nothing can be nested under a <span class="phrase">paragraph</span>, so while a paragraph can be the document block of a SAM document, it would also be the only structure in the document.</p>
<div class="syntax">
<p class="p">The <span class="phrase">document block</span> is not indented. All other structures in the document (excluding <span class="phrase">comments</span>, <span class="phrase">declarations</span>, and <span class="phrase">string definitions</span>) must be children of the <span class="phrase">document block</span>, and therefore must be indented under it. In all other respects, the syntax of the document block is the syntax of it type.</p>
</div>
<div class="semantics">
<p class="p">The <span class="phrase">document block</span> determines the type of the SAM document (just as the root element name in XML forms the type of an XML document). In all other respects, the semantics of the <span class="phrase">document block</span> are no different from the semantics of that structure type.</p>
</div>
<div class="xml-serialization">
<p class="p">The <span class="phrase">document block</span> is serialized according to its block type. In addition, however, if a namespace is declared for the document, the appropriate namespace declaration will be added to the root element generated.</p>
</div>
<div class="html-serialization">
<p class="p">The <span class="phrase">docuemnt block</span> is serialized according to its block type.</p>
</div>
<div class="SOM">
<p class="p">The document block is the only block child of the <span class="phrase"><span class="annotation" data-annotation-type="SOM_object">Root</span></span> object. In every other respect, it is represented as its normal block type.</p>
</div>
</div>
<div class="structure" data-name="paragraph">
<h2 class="title">Paragraph</h2>

<p class="p">A paragraph is a block of text.</p>
<div class="syntax">
<p class="p">A paragraph is indicated as sequence of lines ending with a blank line.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">Now is the time
for all good men
to come to the aid
of the party.

It was the best of 
times, it was the 
worst of times.
</code></pre>
<p class="p">Any line that is not identified as a different structure, or an attempt to create a different structure, is identified as a paragraph.</p>
<p class="p">In some cases a paragraph may begin with a sequence that looks like an attempt to create a different structure. For instance, if there is a colon before the first space in a paragraph, and if the string before the colon is a name-like-value, then the writer can prevent the sequence being recognized as a <span class="phrase">block</span> or <span class="phrase">field</span> by escaping the colon with a backslash or a <span class="phrase">character escape</span>.</p>
<p class="p">Once the first line of a paragraph has been identified, the parser simply accumulates subsequent lines, without looking for other structures, until one of the following is encountered:</p>
<ul class="ul">
<li class="li">
<p class="p">A blank line.</p>
</li>
<li class="li">
<p class="p">A line whose indent is less than the indent of the first line of the paragraph.</p>
</li>
<li class="li">
<p class="p">If the paragraph is the child of a list item, the start of a new list item.</p>
</li>
</ul>
<p class="p">A paragraph cannot have block children. Is is an error if any structure is indented under a paragraph.</p>
<p class="p">The content of a paragraph is a <span class="phrase">flow</span>. A flow is distinct from a simple string value in that it can contain <span class="phrase">phrase</span>s, <span class="phrase">decoration</span>s, <span class="phrase">code</span>, <span class="phrase">annotation</span>s, and <span class="phrase">citation</span>s.</p>
<div class="note">
<p class="p">Some writers may instinctively indent a list under the paragraph it follows. This is an error in SAM. A list is always the peer of the preceding paragraph is SAM and as such the list items must start at the same indent level as the preceding paragraph. The output formatter may, of course, choose to indent lists relative to their sibling paragraphs.</p>
</div>
</div>
<div class="semantics">
<p class="p">A paragraph is block of text. (SAM) has no opinion on whether the block of text would be considered a paragraph in grammatical or literary terms. As far as SAM is concerned, it is simply a block of text set off from other blocks of text and other structures. (This is identical to the meaning of paragraph in most markup languages.)</p>
</div>
<div class="xml-serialization">
<p class="p">A paragraph is serialized as a XML <code class="code">p</code> element. Thus the example above would be serialized as the following XML:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;Now is the time for all good men to come to the aid of the party.&lt;/p&gt;

&lt;p&gt;It was the best of times, it was the worst of times.&lt;/p&gt;
</code></pre>
<p class="p">A paragraph cannot have block children. It is a syntax error to have anything indented under a paragraph.</p>
</div>
<div class="html-serialization">
<p class="p">A paragraph is serialized as an HTML <code class="code">p</code> element.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;p class="p"&gt;Now is the time for all good men to come to the aid of the party.&lt;/p&gt;

&lt;p class="p"&gt;It was the best of times, it was the worst of times.&lt;/p&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A paragraph is represented by a <span class="phrase">Paragraph</span> object with a single child <span class="phrase">Flow</span> object.</p>
</div>
</div>
<div class="structure" data-name="flow">
<h2 class="title">Flow</h2>

<p class="p">A <span class="phrase">flow</span> is a section of document text in a SAM document. A <span class="phrase">flow</span> can contain intra-textual structures like <span class="phrase">annotation</span>s, <span class="phrase">decorations</span>, and <span class="phrase">inline insert</span>s. <span class="phrase">Paragraph</span>s, <span class="phrase">field</span> values, <span class="phrase">block</span> values, and <span class="phrase">variable</span> values are all flows.</p>
<div class="syntax">
<p class="p">There is no special syntax to define a <span class="phrase">flow</span>. Flows are defined by their relationship to other structures.  All flows are trimmed of leading and trailing whitespace. In composing a flow from multiple text lines, all spaces and returns are collapsed to a single space.</p>
</div>
<div class="semantics">
<p class="p">The text in a <span class="phrase">flow</span> is simply text, along with any intra-textual structures it contains.</p>
</div>
<div class="xml-serialization">
<p class="p">The flow object is not represented as an object in XML. Its content becomes the content of whatever element is created to represent the structure that contains the flow.</p>
</div>
<div class="html-serialization">
<p class="p">The flow object is not represented as an object in HTML. Its content becomes the content of whatever element is created to represent the structure that contains the flow.</p>
</div>
<div class="SOM">
<p class="p">A <span class="phrase">flow</span> is contained in a <span class="phrase">Flow</span> object.</p>
</div>
</div>
<div class="structure" data-name="phrase">
<h2 class="title">Phrase</h2>

<p class="p">A phrase structure is a delineated string of text within a <span class="phrase">flow</span>. You create a phrase in order to add an <span class="phrase">attribute</span>, <span class="phrase">annotation</span>, or <span class="phrase">citation</span> to a word or phrase in the text.</p>
<div class="syntax">
<p class="p">A phrase is indicated by surrounding the phrase with curly braces:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In {Rio Bravo}, {the Duke} plays a union colonel.
</code></pre>
<p class="p">It is not an error to have a phrase with no <span class="phrase">attribute</span>s, <span class="phrase">annotation</span>s or <span class="phrase">citation</span>s attached. When such as phrase is found, the parser must:</p>
<ul class="ul">
<li class="li">
<p class="p">First, look backward through the document to find out if the same phrase has been annotated before. If it finds the same phrase, with an annotation, it copies the entire phrase and all attached <span class="phrase">annotation</span>s to the current phrase. The search proceeds in reverse document order and stops at the first instance found.</p>
</li>
<li class="li">
<p class="p">Second, if no matching phrase is found, the parser must issue a warning for the unannotated phrase.</p>
</li>
</ul>
<p class="p">The search is conducted based on the annotation lookup mode in effect for the document, as determines by the <code class="code">annotation-lookup</code> <span class="phrase"><span class="annotation" data-annotation-type="structure">declaration</span></span>.</p>
<p class="p">Note that <span class="phrase">attribute</span>s, <span class="phrase">citations</span>, and <span class="phrase">local annotation</span>s are not copied.</p>
</div>
<div class="semantics">
<p class="p">A phrase has no semantics of its own. Its semantics are determined by any <span class="phrase">annotation</span>s attached to it.</p>
</div>
<div class="xml-serialization">
<p class="p">A phrase is serialized as a <code class="code">phrase</code> element in XML.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;In &lt;phrase&gt;Rio Bravo&lt;/phrase&gt;, &lt;phrase&gt;the Duke&lt;/phrase&gt; plays a union colonel.&lt;/p&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">A phrase is serialized as a <code class="code">span</code> element in HTML with the <code class="code">class</code> element set to <code class="code">phrase</code>.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;p&gt;In &lt;span class="phrase"&gt;Rio Bravo&lt;/phrase&gt;, &lt;span class="phrase"&gt;the Duke&lt;/phrase&gt; plays a union colonel.&lt;/p&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A phrase is represented by a <span class="phrase">Phrase</span> object.</p>
</div>
</div>
<div class="structure" data-name="attribute">
<h2 class="title">Attribute</h2>

<p class="p">Attributes are metadata on a <span class="phrase">block</span> or <span class="phrase">phrase</span>. Unlike XML, which allows for an infinite number and type of attributes, SAM supports a limited set of attributes, with the attribute type being indicated by its position or by a prefixed symbol. If you need attributes not in this set supplied by SAM, you will have to model them as <span class="phrase">field</span>s instead.</p>
<div class="syntax">
<p class="p">Attributes on blocks are contained in parentheses that follow the colon of a <span class="phrase">block</span> header with no space:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">name:(?BC) Fred Flintstone
</code></pre>
<p class="p">A block can have multiple attributes, one after another, with no spaces between:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">name:(?BC)(#fred) Fred Flintstone 
</code></pre>
<p class="p">Attributes on <span class="phrase">phrases</span> are contained in parentheses that follow the closing curly brace of the phrase or the closing parenthesis or bracket of another <span class="phrase">annotation</span>, <span class="phrase">attribute</span>, or <span class="phrase">citation</span>.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam"></code></pre>
<p class="p">An attribute annotation looks like this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In Quebec, a stop sign says {Arrt}(!fr).
</code></pre>
<p class="p">A <span class="phrase">phrase</span> can have an unlimited mix of attributes, <span class="phrase">annotation</span>s, and <span class="phrase">citation</span>s attached to it.</p>
<p class="p">There are four <span class="phrase">general attributes</span>. The type of an attribute it determined by the flag character that precedes it. The four general types are:</p>
<ul class="ul">
<li class="li">
<p class="p"><span class="phrase">Condition</span>, which start with a <code class="code">?</code></p>
</li>
<li class="li">
<p class="p"><span class="phrase">Name</span>, which start with <code class="code">#</code></p>
</li>
<li class="li">
<p class="p"><span class="phrase">ID</span>, which start with <code class="code">*</code></p>
</li>
<li class="li">
<p class="p"><span class="phrase">Language code</span>, which start with <code class="code">!</code></p>
</li>
</ul>
<p class="p">A block or phrase can only have one name, ID, or Language code attribute but it may have an umlimited number of condition attributes.</p>
<p class="p">Condition expressions must not include commas.</p>
<p class="p">Names must be SAM <span class="phrase"><a href="#nametoken">name tokens</a></span>.</p>
<p class="p">IDs must be SAM <span class="phrase">name tokens</span>.</p>
<p class="p">Languages should be <span class="phrase"><a href=https://www.w3.org/International/articles/language-tags/ class="link">BCP 47</a></span> language codes, but the parser is not required to enforce this.</p>
<p class="p">Certain block types take additional attributes with meanings specific to those block types.</p>
</div>
<div class="semantics">
<p class="p">Attributes provide support for basic <span class="phrase">management domain</span> metadata in a SAM file.</p>
<p class="p">Unlike XML, SAM does not support arbitrarily named attributes. Only a fixed set of management attributes are supported. The semantics of each attribute type is as follows:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">Condition</dt>
<dd class="ll.li.item"><p class="p">A <span class="phrase">condition</span> attribute is used to determine if a block should appear in a particular output or not. If the condition expression evaluates to true, then the block is included. If it evaluates to false, it is not included.</p>
<p class="p">Conditions are evaluated from the outside in, so if a block is conditionally excluded, all its contents are excluded, regardless of any conditional expressions that may occur on any of its children.</p>
<p class="p">The syntax, interpretation, and truth values of condition expressions are left entirely to the application layer. Similarly, including or excluding blocks is left entirely to the application layer.</p>
<p class="p">Multiple conditions may be applied to the same block.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">ID</dt>
<dd class="ll.li.item"><p class="p">An <span class="phrase">id</span> attribute assigns an ID to a block. That id can be referenced by an <span class="phrase">idref</span>. IDs must be unique in a file. IDRefs must refer to an ID in the current file. The action to be taken by the application layer on encountering an IDref is up to the tagging language designer.</p>
<p class="p">Multiple ids are not permitted on the same block.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">Name</dt>
<dd class="ll.li.item"><p class="p">A <span class="phrase">name</span> attribute assigns a name to a block. A name performs the same function as an ID, allowing the block to be referenced from elsewhere. However, there are no limits on the scope of names. Uniqueness of names is not enforced. Name references are not required to match a name in the current file. This allows you to use names to reference blocks in other files. (Note the namerefs so not support naming the file in which a name is located. Rather it is left to the application layer to locate names by whatever mechanism seems appropriate.)</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">Language code</dt>
<dd class="ll.li.item"><p class="p">A <span class="phrase">language code</span> attribute specified the language in which the content of a block or phrase is written. It is expected, but not required, that standard <span class="phrase"><a href=https://www.w3.org/International/articles/language-tags/ class="link">BCP 47</a></span> language codes be used to identify languages.</p>
</dd>
</div>
</dl>
<p class="p">Certain block types have additional attributes that are specific to those block types. See the relevant entries for details.</p>
<p class="p">This is the list of the standard attributes allowed on each structure. Block types that take special attributes are indicated with &lt;special&gt;:</p>
<table class="grid">
<tr class="row">
<td class="cell">block</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">field</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">fragment</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">grid</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">recordset</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">ordered-list-item</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">unorderd-list-item</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">line</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">blockquote</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">phrase</td>
<td class="cell">!language</td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">codeblock</td>
<td class="cell"></td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell">&lt;special&gt;</td>
</tr>
<tr class="row">
<td class="cell">string-def</td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">paragraph</td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">record</td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
</tr>
<tr class="row">
<td class="cell">block insert</td>
<td class="cell"></td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell">&lt;special&gt;</td>
</tr>
<tr class="row">
<td class="cell">inline insert</td>
<td class="cell"></td>
<td class="cell">#name</td>
<td class="cell">?condition</td>
<td class="cell">*id</td>
<td class="cell">&lt;special&gt;</td>
</tr>
<tr class="row">
<td class="cell">include</td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell"></td>
<td class="cell">&lt;special&gt;</td>
</tr>
</table>
<div class="note">
<p class="p">Note that the lack of arbitrary named attributes does not reduce the semantic flexibility of SAM as compared to XML. Any metadata that can be expressed by an attribute on a block can also be expressed by a field that is a child of that block. The reason for using attributes in XML is to preserve a pure distinction between text and metadata, but that is not a design consideration in SAM, which is meant for the creation of new text through structured writing, not for the annotation of existing texts for study.</p>
</div>
</div>
<div class="xml-serialization">
<p class="p">Attributes are represented in XML by XML attributes on the block element.</p>
<ul class="ul">
<li class="li">
<p class="p"><span class="phrase">language</span> is represented by an <code class="code">xml:lang</code> attribute.</p>
</li>
<li class="li">
<p class="p"><span class="phrase">ID</span> is represented by an <code class="code">id</code> attribute.</p>
</li>
<li class="li">
<p class="p"><span class="phrase">name</span> is represented by a <code class="code">name</code> attribute.</p>
</li>
<li class="li">
<p class="p"><span class="phrase">condition</span>s are represented by a <code class="code">conditions</code> attribute. If multiple condition attributes are applied in SAM, they will be concatenated with commas in the <code class="code">conditions</code> attribute value.</p>
</li>
</ul>
<p class="p">Attributes on <span class="phrase">phrases</span> are serialized wrapped around the phrase to which they apply just as described for <span class="phrase">annotations</span>.</p>
</div>
<div class="html-serialization">
<p class="p">Attributes are represented in HTML by HTML attributes on the block or phrase element.</p>
<ul class="ul">
<li class="li">
<p class="p"><span class="phrase">language</span> is represented by an <code class="code">lang</code> attribute.</p>
</li>
<li class="li">
<p class="p"><span class="phrase">ID</span> is represented by an <code class="code">id</code> attribute.</p>
</li>
<li class="li">
<p class="p"><span class="phrase">name</span> is represented by a <code class="code">data-name</code> attribute.</p>
</li>
<li class="li">
<p class="p"><span class="phrase">condition</span>s are represented by a <code class="code">data-conditions</code> attribute. If multiple condition attributes are applied in SAM, they will be concatenated with commas in the <code class="code">data-conditions</code> attribute value.</p>
</li>
</ul>
<p class="p">Attributes on <span class="phrase">phrases</span> are serialized wrapped around the phrase to which they apply just as described for <span class="phrase">annotations</span>.</p>
</div>
<div class="SOM">
<p class="p">Attributes on <span class="phrase">blocks</span> are represented by equivalent attributes of the <span class="phrase">Block</span> object.</p>
<p class="p">Attributes on <span class="phrase">phrases</span> are represented by equivalent attributes of the <span class="phrase">Phrase</span> object.</p>
</div>
</div>
<div class="structure" data-name="annotation">
<h2 class="title">Annotation</h2>

<p class="p">Annotations clarify what a piece of text is about. Whereas the role of an <span class="phrase">attribute</span> is to attach management metadata, the role of an attribute is to attach metadata that clarifies exactly what the phrase is describing so that it can be reliably processed by algorithms.</p>
<div class="syntax">
<p class="p">An <span class="phrase">annotation</span> is attached to a phrase and is expressed as an expression in parentheses following the closing <code class="code">}</code> of the phrase with no space in between.</p>
<p class="p">An annotation specifies the type of a string. Here the type expression says that the string "Rio Bravo" is a reference to a movie:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In {Rio Bravo}(movie), {the Duke}(actor "John Wayne" (SAG)) plays a union colonel.
</code></pre>
<p class="p">There are three parts to an annotation:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">type</dt>
<dd class="ll.li.item"><p class="p">The first word immediately following the opening parentheses is the type of the subject being annotated. In the sample above, "Rio Bravo" is a movie and "the Duke" is an actor. An annotation type must be a valid SAM <span class="phrase">name</span>. The annotation type is required.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">specifically</dt>
<dd class="ll.li.item"><p class="p">In some cases, the annotated text may not specify its subject clearly. In this case, the specifically attribute is use to clarify what is meant. The specifically attribute is a string in double or single straight quotes. In the sample above, "the Duke" means, specifically, "John Wayne". The specifically attribute is optional.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">namespace</dt>
<dd class="ll.li.item"><p class="p">In some cases, it is necessary to specify the namespace to which the annotated term belongs. The namespace attribute follows the specifically attribute (if specified) and is contained in parentheses. In the sample above, the name of the actor "John Wayne" is part of a set of names managed by the Screen Actors Guild which makes sure two actors don't use the same stage name. (In most cases, the namespace is implied by the type, so you will not usually need to specify it.) The namespace attribute is optional. (Note that the namespace attribute of an annotation is not related to the concept of the namespace of an block or field name. It is the namespace of the value, not the namespace of the container.)</p>
</dd>
</div>
</dl>
<p class="p">If you are annotating the same phrase more than one in the same file. You can skip the annotation metadata and just use curly braces around the phrase. The parser will copy the metadata from the last occurring instance of that same phrase.</p>
</div>
<div class="semantics">
<p class="p">The specific semantics of individual annotation depend on the language designer, however, in order to maintain consistency across languages, it is important to use the specifically and namespace attributes for their intended purposes and not to hijack them to express some other semantics.</p>
<p class="p">Annotations may be from any of the <span class="phrase">structured writing domains</span> (media, document, subject, management). The relationship between the annotation type and the meaning of the specifically attribute changes in each domain.</p>
<p class="p">In the media domain, the annotation type refers to some media property to be applied to the text, and the specifically attribute supplies more specific information. For example it could be <code class="code">{the Duke}(highlight "yellow")</code> or <code class="code">{the Duke}(link "http://JohnWayne.com")</code>.</p>
<p class="p">In the document domain, the annotation type refer to some document property, and the specifically attribute supplies more specific information. For example, it could be <code class="code">{the Duke}(index "Wayne, John")</code>.</p>
<p class="p">In the subject domain, the annotation type refers to the type of the subject being referred to and the specifically attribute clarifies the intended subject if required. For example `<span class="phrase"><span class="annotation" data-annotation-type="actor" data-specifically="John Wayne">the Duke</span></span>.</p>
<p class="p">The key to using the annotation attributes correctly is simply to make sure that the attribute names apply in a reasonable fashion to the values they contain. If they don't, a different markup strategy should be used.</p>
</div>
<div class="xml-serialization">
<p class="p">An annotation is serialized to XML as an <code class="code">&lt;annotation&gt;</code> element. The type, specifically, and namespace attributes become attributes with those names in XML.</p>
<p class="p">The <code class="code">&lt;annotation&gt;</code> element is wrapped inside the <code class="code">&lt;phrase&gt;</code> element that it annotation, with the content of the phrase on the inside.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;In &lt;phrase&gt;&lt;annotation type="movie"&gt;Rio Bravo&lt;/annotation&gt;&lt;/phrase&gt;, &lt;phrase&gt;&lt;annotation type="actor" specifically="John Wayne" namespace="SAG&gt;the Duke&lt;/annotation&gt;&lt;/phrase&gt; plays a union colonel.&lt;/p&gt;
</code></pre>
<p class="p">When a phrase has one or more annotations, those annotations are wrapped inside the <code class="code">&lt;phrase&gt;</code> element in the order in which they occur in the source document. Thus the following:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">The film starred {John Wayne}(actor)(director), who also directed.
</code></pre>
<p class="p">would be serialized as:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;The film starred &lt;phrase&gt;&lt;annotation type="actor"&gt;&lt;annotation type="director"&gt;John Wayne&lt;/annotation&gt;&lt;/annotation&gt;&lt;/phrase&gt;, who also directed.
</code></pre>
</div>
<div class="html-serialization">
<p class="p">An annotation is serialized to HTML as an <code class="code">&lt;span&gt;</code> element with the <code class="code">class</code> attribute set to <code class="code">annotation</code>. The type attribute is serialized as a <code class="code">data-annotation-type</code> attribute, the specifically attribute as a <code class="code">data-specifically</code> attribute, and the <code class="code">namespace</code> attributes as a <code class="code">data-namespace</code> attribute.</p>
<p class="p">&lt;span class="annotation" data-annotation-type="foo"&gt;</p>
<p class="p">The <code class="code">&lt;annotation&gt;</code> element is wrapped inside the <code class="code">&lt;phrase&gt;</code> element that it annotates, with the content of the phrase on the inside.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;p class="p"&gt;In &lt;span class="phrase"&gt;&lt;span class="annotation" data-annotation-type="movie"&gt;Rio Bravo&lt;/span&gt;&lt;/span&gt;, &lt;phrase&gt;&lt;span class="annotation" data-annotation-type="actor" data-specifically="John Wayne" data-namespace="SAG&gt;the Duke&lt;/span&gt;&lt;/span&gt; plays a union colonel.&lt;/p&gt;
</code></pre>
<p class="p">When a phrase has one or more annotations, those annotations are wrapped inside the <code class="code">&lt;phrase&gt;</code> element in the order in which they occur in the source document. Thus the following:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">The film starred {John Wayne}(actor)(director), who also directed.
</code></pre>
<p class="p">would be serialized as:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;p class="p"&gt;The film starred &lt;span class="phrase"&gt;&lt;span class="annotation" data-annotation-type="actor"&gt;&lt;span class="annotation" data-annotation-type="director"&gt;John Wayne&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;, who also directed.
</code></pre>
</div>
<div class="SOM">
<p class="p">An annotation is represented in the <span class="phrase">SOM</span> by an Annotation object.</p>
</div>
</div>
<div class="structure" data-name="citation">
<h2 class="title">Citation</h2>

<p class="p">Citations are a reference to another resource. This includes internal references to other structures within the document, such as to a graphic,procedure, or footnote, as well as references to external works. Citations are supported wherever <span class="phrase">attributes</span> or <span class="phrase">annotations</span> are supported.</p>
<p class="p">Citations come in two form. Textual citations cite a resource using whatever citation format the language designer or writer wishes to use. Reference citations cite a resource by its <span class="phrase">id</span>, <span class="phrase">name</span>, or <span class="phrase">key</span>.</p>
<div class="syntax">
<p class="p">A citation is created using square brackets:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">Moby Dick[Melville, 1851] is about a big fish.
</code></pre>
<p class="p">They can also be applied to a phrase, rather then floating in the text.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">{Moby Dick}[Melville, 1851] is about a big fish.
</code></pre>
<p class="p">Citations can be chained with annotations:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">{Moby Dick}(novel)[Melville, 1851] is about a big fish.
</code></pre>
<p class="p">Citations can also be added to <span class="phrase">blocks</span>. The most obvious application of this is <span class="phrase">blockquote</span>s:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">"""[Melville, 1851] 
    Call me Ishmael.
</code></pre>
<p class="p">SAM has no opinion about the format of a citation text. That is entirely up to the application layer to decipher.</p>
<p class="p">You can  use reference citations to reference other parts of the current document or other documents. To cite a resource that has an id within the current SAM document, reference the id like this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">Moby Dick is about a big fish[*fn.moby]. See [*fig.whale].

fig:(*whale)
    &gt;&gt;&gt;(image whale.png)

footnote:(*moby)
    Actually, Moby Dick is a whale, not a fish.
</code></pre>
<p class="p">Citation by <span class="phrase">id</span>, <span class="phrase">name</span>, or <span class="phrase">key</span> can include additional information. For example, if you have a bibliography where each bibliography entry has a name assigned to it, you could cite the work by reference to the name, and then add additional information for the page number.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">"""[#Moby page 1] 
    Call me Ishmael.
</code></pre>
<p class="p">The additional information is anything between the end of the <span class="phrase">name</span> and the closing square bracket.</p>
</div>
<div class="semantics">
<p class="p">The function of a citation is to generate a piece of content in the output that is a reference to the specified resource. Some text should always be generated in the place where the citation is specified. What type of reference that is depends of the type of object that is being referenced. Generating such references is the job of the <span class="phrase">application layer</span>.</p>
<p class="p">The purpose of a citation is not to create a link. Links should be created using <span class="phrase">annotation</span>s. However, the reference generated by a citation may include a link to the resource in question if appropriate.</p>
<p class="p">The semantics of a reference by <span class="phrase">id</span>, <span class="phrase">name</span>, or <span class="phrase">key</span>, depend on the type of the structure referred to. This is different from the usage in some specific markup languages in XML where there may be a specific element used to reference a footnote, such as <code class="code">&lt;footnote idref="fn.moby"/&gt;</code>. In SAM, all references are generic citations, which would serialize as &lt;citation idref="fn.moby"&gt;. This means that in order for the application layer to determine what kind of reference to generate for a citation, it needs to look up the type of the resource being referenced. Thus to determine that it should create a footnote reference, the application layer needs to look up the structure with the id <code class="code">fn.moby</code> and determine its type. Once it determines that the type is footnote, it knows to create a footnote reference.</p>
<p class="p">While it is not required, it is a good idea for markup designers and writers to adopt and follow a convention for naming the IDs and names of structures to reflect their type, such as in the use of <code class="code">fn.</code> and <code class="code">fig.</code> prefixes in these examples.</p>
<p class="p">The semantics of a citation of an external work is that it will generate a reference to that work in whatever citation format is appropriate for publication. This means that a citation that is inline in the SAM document does not necessarily imply that an inline citation format will be used on output. The SAM citation is just capturing the citation information. It is up to the application layer to decide how to present it, including removing the citation to a footnote or endnote if appropriate. The language designer is entitled to specify any citation format they like, and to interpret it in any way they like.</p>
<p class="p">Additional information in a citation is simply passed through to the application layer. SAM does not specify any semantics for it.</p>
</div>
<div class="xml-serialization">
<p class="p">A <span class="phrase">citation</span> is output as a <code class="code">&lt;citation&gt;</code> element in XML.</p>
<p class="p">The type of the citation is indicated by a <code class="code">type</code> attribute. The supported types are:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">citation</dt>
<dd class="ll.li.item"><p class="p">A textual citation.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">id</dt>
<dd class="ll.li.item"><p class="p">A SAM <span class="phrase">ID</span>.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">name</dt>
<dd class="ll.li.item"><p class="p">A SAM <span class="phrase">name</span>.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">key</dt>
<dd class="ll.li.item"><p class="p">A SAM <span class="phrase">key</span>.</p>
</dd>
</div>
</dl>
<p class="p">The value of the citation is indicated by the <code class="code">value</code> attribute.</p>
<p class="p">For example,</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;Moby Dick&lt;citation type="citation" value="Melville, 1851"&gt; is about a big fish.
</code></pre>
<p class="p">If the citation is attached to a phrase, then the citation will be wrapped around the text of the phrase and nested inside the <code class="code">&lt;phrase&gt;</code> element:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;&lt;phrase&gt;&lt;citation type="citation" value="Melville, 1851"/&gt;Moby Dick&lt;/phrase&gt; is about a big fish.
</code></pre>
<p class="p">If a citation and an annotation are attached to the same phrase, then the citation will be nested within the <code class="code">&lt;phrase&gt;</code> element and relative to any <code class="code">&lt;annotation&gt;</code> elements, just as with <span class="phrase">annotation</span> nesting.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;phrase&gt;&lt;annotation type="novel"&gt;&lt;citation type="citation" value="Melville, 1851"&gt;Moby Dick&lt;/citation&gt;&lt;/annotation&gt;&lt;/phrase&gt; is about a big fish.
</code></pre>
<p class="p">If the citation is attached to a <span class="phrase">blockquote</span>, the citation element will be nested inside the <code class="code">&lt;blockquote&gt;</code> element.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&lt;blockquote&gt;
    &lt;citation type="citation" value="Melville, 1851"/&gt; 
    &lt;p&gt;Call me Ishmael.&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>
<p class="p">If a citation contains additional information, it is included as an <code class="code">extra</code> attribute.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&lt;blockquote&gt;
    &lt;citation type="nameref" value="Moby" extra="page 1"/&gt; 
    &lt;p&gt;Call me Ishmael.&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>
<div class="note">
<p class="p">Unlike other blocks, the serialization of a <span class="phrase">citation</span> does not include a line feed after the citation tag. This is because a citation can also occur inside a flow, where the addition of a line feed would introduce extra whitespace into the flow. The lack of a linefeed in a block context does not change the semantics of the resulting document, but can make a difference in tests that compare literal XML output to expected output.</p>
</div>
</div>
<div class="html-serialization">
<p class="p">A textual <span class="phrase">citation</span> is output as a <code class="code">&lt;cite&gt;</code> element in HTML.</p>
<p class="p">A reference citation by ID that is attached to a <span class="phrase">phrase</span> it output as a link to the referenced structure.</p>
<p class="p">Other types of reference citations are not supported in HTML output mode. If you need to resolve reference citations, use XML output mode and process the XML output to produce the citation style you need for your output.</p>
<p class="p">For example,</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;p&gt;Moby Dick&lt;cite&gt;Melville, 1851&lt;/cite&gt; is about a big fish.
</code></pre>
<p class="p">If the textual citation is attached to a phrase, then the citation will be wrapped around the text of the phrase and nested inside the <code class="code">&lt;phrase&gt;</code> element:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;&lt;phrase&gt;&lt;cite&gt;Melville, 1851&lt;/cite&gt;Moby Dick&lt;/phrase&gt; is about a big fish.
</code></pre>
<p class="p">If a textual citation and an annotation are attached to the same phrase, then the citation will be nested within the <code class="code">&lt;phrase&gt;</code> element and relative to any <code class="code">&lt;annotation&gt;</code> elements, just as with <span class="phrase">annotation</span> nesting.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;phrase&gt;&lt;span class="annotation" annotation-type="novel"&gt;&lt;cite type="citation" value="Melville, 1851"&gt;Moby Dick&lt;/cite&gt;&lt;/span&gt;&lt;/span&gt; is about a big fish.
</code></pre>
<p class="p">If the citation is attached to a <span class="phrase">blockquote</span>, the citation element will be nested inside the <code class="code">&lt;div&gt;</code> element.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&lt;div class="blockquote"&gt;
    &lt;cite&gt;Melville, 1851&lt;/cite&gt; 
    &lt;p&gt;Call me Ishmael.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A <span class="phrase">citation</span> is represented in the SOM by a <span class="phrase"><span class="annotation" data-annotation-type="object">Citation</span></span> object.</p>
<p class="p">When applied to a <span class="phrase">block</span>, the <span class="phrase"><span class="annotation" data-annotation-type="object">Citation</span></span> object is added as the first child of the block.</p>
<p class="p">When applied to a <span class="phrase">phrase</span>, the <span class="phrase"><span class="annotation" data-annotation-type="object">Citation</span></span> object is chained in sequence with any other citations or annotations.</p>
<p class="p">When a <span class="phrase"><span class="annotation" data-annotation-type="object">citation</span></span> occurs standalone in a flow, the <span class="phrase"><span class="annotation" data-annotation-type="object">Citation</span></span> object becomes an item in the <span class="phrase">Flow</span> object list.</p>
</div>
</div>
<div class="structure" data-name="insert">
<h2 class="title">Insert</h2>

<p class="p">An insert is an instruction to the <span class="phrase">application layer</span> to insert a resource into the document output.</p>
<p class="p">Inserts may be created at the <span class="phrase">block</span> level or inside a <span class="phrase">flow</span>.</p>
<div class="syntax">
<p class="p">At the block level, an insert is placed on a line by itself and is indicated by three greater-than signs:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&gt;&gt;&gt;(image foo.png)
</code></pre>
<p class="p">Inside a <span class="phrase">flow</span>, an insert is indicated by a single greater-than followed the the identification of the resource in parentheses:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">My favorite flavor of ice cream is &gt;($favorite-flavor).
</code></pre>
<p class="p">The resource to be inserted may be identified either by type and URL as in the block example above or by reference to an <span class="phrase">id</span>, <span class="phrase">name</span>, <span class="phrase">variable</span>, or <span class="phrase">key</span>.</p>
<p class="p">You can also assign <span class="phrase">name</span>s, <span class="phrase">condition</span>s, or <span class="phrase">id</span>s to an insert. For example, to insert a fragment containing the introduction to the deluxe version of a product, you could do this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&gt;&gt;&gt;(~deluxe-intro)(?model=deluxe)
</code></pre>
<p class="p">Remember that it is up to the application layer to implement such inserts.</p>
<p class="p">You can use any name you like for the insert type, however the following types are reserved so that editors can act on them to provide enhanced views of the document while editing:</p>
<ul class="ul">
<li class="li">
<p class="p">image</p>
</li>
<li class="li">
<p class="p">video</p>
</li>
<li class="li">
<p class="p">audio</p>
</li>
<li class="li">
<p class="p">feed</p>
</li>
<li class="li">
<p class="p">app</p>
</li>
<li class="li">
<p class="p">object</p>
</li>
</ul>
<p class="p">They should be used only with their natural semantics. Note, however, that the spec does not prescribe a mechanism for identifying the object to insert. The item will, of course, be identified by a URL, but how that URL is to be interpreted is not specified. For instance, it could point to an intermediate resource such as an XML file that contains information used to choose the appropriate object for a particular media. The SAM language spec does not specify the format or interpretation for such a file.</p>
</div>
<div class="semantics">
<p class="p">The insert is an instruction to the application layer to insert the specified resource. While implementation is entirely up to the applications layer, SAM specifies the semantics of the reserved insert types as follows:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">image</dt>
<dd class="ll.li.item"><p class="p">Insert the graphic image into the output.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">video</dt>
<dd class="ll.li.item"><p class="p">Insert the video into the output.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">audio</dt>
<dd class="ll.li.item"><p class="p">Insert a playable audio clip into the output.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">feed</dt>
<dd class="ll.li.item"><p class="p">Insert the result of a feed into the output.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">app</dt>
<dd class="ll.li.item"><p class="p">Insert an embedded app into the output.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">object</dt>
<dd class="ll.li.item"><p class="p">Inserts a generic object (per HTML5 'object' tag.)</p>
</dd>
</div>
</dl>
<p class="p">The semantics of inserting by reference to an <span class="phrase">ID</span>, <span class="phrase">name</span>, or <span class="phrase">variable</span>, or <span class="phrase">key</span> are as follows:</p>
<dl class="ll">
<div class="ll.li">
<dt class="ll.li.label">a SAM <span class="phrase">ID</span></dt>
<dd class="ll.li.item"><p class="p">Insert the resource pointed to by the <span class="phrase">ID</span> in a manner appropriate to its type.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">a SAM <span class="phrase">name</span></dt>
<dd class="ll.li.item"><p class="p">Insert the resource pointed to by the <span class="phrase">name</span> in a manner appropriate to its type.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">a SAM <span class="phrase">variable</span></dt>
<dd class="ll.li.item"><p class="p">Insert the value of the variable into the document, and process any structures it contains.</p>
</dd>
</div>
<div class="ll.li">
<dt class="ll.li.label">a SAM <span class="phrase">key</span></dt>
<dd class="ll.li.item"><p class="p">Insert the resource pointed to by the <span class="phrase">key</span> in a manner appropriate to its type.</p>
</dd>
</div>
</dl>
<p class="p">Note that you are not obliged to use any of these types in order to do their assigned functions. You can devise any insert types you like, since responsibility for implementing them rests entirely with the application layer. The constraint is that you should not assign other semantics to these names. Having a standard set simply allows for editors to presume the semantics of the basic types and act on them if they wish.</p>
</div>
<div class="xml-serialization">
<p class="p">In XML output mode the insert instruction is simply passed through to the application layer like this:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;insert item="foo.gif" type="image"/&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">In HTML output mode, the parser will attempt to insert the inserted object in the output.</p>
<p class="p">For direct inserts, it will check if the insert type is in its list of known insert types and the file extension is in its list of known file types. If both conditions are true, it will insert it in the document using an HTML <code class="code">object</code> element. For a block insert, the <code class="code">object</code> element will be wrapped in a <code class="code">div</code> element with the class attribute set to <code class="code">insert</code> as well as any of the standard attributes that are present:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;div class="insert" data-conditions="a,b" id="id15" data-name="name"&gt;&lt;object data="foo.gif"&gt;&lt;/object&gt;&lt;/div&gt;
</code></pre>
<p class="p">Treatment of an inline direct insert is identical except that the wrapper element is a <code class="code">span</code>:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;span class="insert" data-conditions="a,b" id="id15" data-name="name"&gt;&lt;object data="foo.gif"&gt;&lt;/object&gt;&lt;/span&gt;
</code></pre>
<p class="p">The known insert types for purposes of HTML output are: "image", "video", "audio", "feed", "app", and "object".</p>
<p class="p">The known file types for purposes of HTML output are: ".gif", ".jpeg", ".jpg", ".png", ".apng", ".bmp", ".svg", ".ico", ".ogv", ".ogg", ".mp4", ".m4a", ".m4p", ".m4b", ".m4r", ".m4v", ".webm", ".oga", ".l16", ".wav", ".aiff", ".au", ".pcm", ".mp3", ".m4a", ".mp4", ".3gp", ".m4a", ".m4b", ".m4p", ".m4r", ".m4v", ".aac", ".spx", ".opus", ".atom", ".rss", and ".jar".</p>
<p class="p">If the insert type or file type are not in the lists, a warning is issued and the insert is ignored.</p>
<p class="p">For inserts by reference, HTML output mode attempts to find and resolve certain types by looking up the referenced structure and inserting it at the point of the insert. HTML output mode does not guarantee that the results of inserting a structure from elsewhere in the document will produce valid HTML in all cases. The following insert by reference cases are supported:</p>
<ul class="ul">
<li class="li">
<p class="p">Inline inserts of variables.</p>
</li>
<li class="li">
<p class="p">Inserts by ID.</p>
</li>
<li class="li">
<p class="p">Inserts by name if the named structure is found in the current document.</p>
</li>
</ul>
<p class="p">Block inserts of strings and inserts by key are not supported. If these insert types are found, or if the referenced structure cannot be found, a warning is issued and the insert is ignored.</p>
</div>
<div class="SOM">
<p class="p">A block insert is represented by a <span class="phrase">BlockInsert</span> object. An inline-insert is represented by an <span class="phrase">InlineInsert</span> object.</p>
<p class="p">The list of known insert types used for HTML serialization is stored in the global variable <code class="code">known_insert_types</code>.</p>
<p class="p">The list of known file types used for HTML serialization is stored in the global variable <code class="code">known_file_types</code>.</p>
</div>
</div>
<div class="structure" data-name="record-set">
<h2 class="title">Record set</h2>

<p class="p">A record set is a set of records (like a database table) inserted into the document.</p>
<div class="syntax">
<p class="p">A recordset consists of a set of records, one per line, with named fields. The recordset declaration consists of the record set name followed by two colons and then the names of the fields, separated by commas.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">history:: date, author, status, notes
</code></pre>
<p class="p">Each line indented below the record set declaration is a record, which contains field values separated by commas.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">history:: date, author, status, notes
    2018-01-23, mbaker, draft, First draft
    2018-01-29, jsmith, draft, Added info on haggis
    2018-02-04, ajones, approved, Reviewed and approved with minor changes
</code></pre>
</div>
<div class="semantics">
<p class="p">A record set is a simple database table. Its purpose is to provide a <span class="phrase">subject-domain</span> container for some of the classes of information that are commonly presented as tables in the <span class="phrase">document domain</span>, allowing greater freedom to query the information in the document or to present the information in various different ways.</p>
</div>
<div class="xml-serialization">
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;history&gt;
&lt;record&gt;
&lt;date&gt;2018-01-23&lt;/date&gt;
&lt;author&gt;mbaker&lt;/author&gt;
&lt;status&gt;draft&lt;/status&gt;
&lt;notes&gt;First draft&lt;/notes&gt;
&lt;/record&gt;
&lt;record&gt;
&lt;date&gt;2018-01-29&lt;/date&gt;
&lt;author&gt;jsmith&lt;/author&gt;
&lt;status&gt;draft&lt;/status&gt;
&lt;notes&gt;Added info on haggis&lt;/notes&gt;
&lt;/record&gt;
&lt;record&gt;
&lt;date&gt;2018-02-04&lt;/date&gt;
&lt;author&gt;ajones&lt;/author&gt;
&lt;status&gt;approved&lt;/status&gt;
&lt;notes&gt;Reviewed and approved with minor changes&lt;/notes&gt;
&lt;/record&gt;
&lt;/history&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">HTML serialization includes an empty header so you can add appropriate header labels through CSS.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;table class="recordset"&gt;
&lt;thead class="recordset-header"&gt;
&lt;tr class="recordset-header-row"&gt;
&lt;th class ="record-set-field" data-field-name="date"&gt;&lt;/th &gt;
&lt;th class ="record-set-field" data-field-name="author"&gt;&lt;/th &gt;
&lt;th class ="record-set-field" data-field-name="status"&gt;&lt;/th &gt;
&lt;th class ="record-set-field" data-field-name="notes"&gt;&lt;/th &gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody class="recordset-body"&gt;
&lt;tr class="record"&gt;
&lt;td class="record-field" data-field-name="date"&gt;2018-01-23&lt;/td&gt;
&lt;td class="record-field" data-field-name="author"&gt;mbaker&lt;/td&gt;
&lt;td class="record-field" data-field-name="status"&gt;draft&lt;/td&gt;
&lt;td class="record-field" data-field-name="notes"&gt;First draft&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="record"&gt;
&lt;td class="record-field" data-field-name="date"&gt;2018-01-29&lt;/td&gt;
&lt;td class="record-field" data-field-name="author"&gt;jsmith&lt;/td&gt;
&lt;td class="record-field" data-field-name="status"&gt;draft&lt;/td&gt;
&lt;td class="record-field" data-field-name="notes"&gt;Added info on haggis&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="record"&gt;
&lt;td class="record-field" data-field-name="date"&gt;2018-02-04&lt;/td&gt;
&lt;td class="record-field" data-field-name="author"&gt;ajones&lt;/td&gt;
&lt;td class="record-field" data-field-name="status"&gt;approved&lt;/td&gt;
&lt;td class="record-field" data-field-name="notes"&gt;Reviewed and approved with minor changes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A recordset is represented by a RecordSet object. Each record is represented by Record object which is a child of the RecordSet object.</p>
</div>
</div>
<div class="structure" data-name="codeblock">
<h2 class="title">Codeblock</h2>

<p class="p">A codeblock is a block of computer code or data, or any other material with its own syntax that is to be presented as part of the document content. The contents of a codeblock are not interpreted by the SAM parser but are presented as entered in the source.</p>
<div class="syntax">
<p class="p">Codeblocks begin with three back ticks followed by optional <span class="phrase">attribute</span>s.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">```(python)
    print("Hello World.")
</code></pre>
<p class="p">Code must be indented under the codeblock marker. The codeblock ends at the first line that is less indented than the codeblock marker, or at the end of the file.</p>
<p class="p">Codeblocks take the standard <span class="phrase">attribute</span> types.</p>
<p class="p">Because is is delineated by indentation, the contents of a codeblock do not require any character escaping, and no SAM character escapes are recognized in a codeblock. The text is taken literally without modification of any kind.</p>
<p class="p">Thus, for instance, you can show blocks of SAM in a SAM codeblock (as this document does) without any need for escaping any part of the markup.</p>
</div>
<div class="semantics">
<p class="p">The text of the codeblock is not processed as SAM markup. It is recorded as is with no interpretation or escape processing. Line breaks are preserved as in the original.</p>
<p class="p">Because indentation may be significant in a codeblock, and because the code will be indented under the codeblock header in the SAM source, the SAM parser uses the following algorithm to distinguish SAM indenting from indenting in the code itself: The parser looks at all the lines that are indented under the codeblock header, finds the one with the smallest indent, and treats it as occurring at the first column in the code. This allows for cases where the first line of a code sample may not be the least indented line. (That is, the first line of the code sample may be more indented than some of the lines that follow.) It also means that all codeblocks will be formatted with zero initial indent.</p>
<p class="p">The semantics of the language attribute are slightly different for codeblocks, or at least, the implication of the semantics is. For other blocks, the language attribute denotes the human language of the text. For a codeblock, it denotes the computer or data language of the codeblock. In the unlikely event that you need to apply both languages, you should use a wrapper around the codeblock to capture the human language. For example, you might do this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">code-sample:(fr)
    ```(sam)
        La Plume de ma Tante.
</code></pre>
</div>
<div class="xml-serialization">
<p class="p">A codeblock is serialized like this:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;codeblock conditions="a,b" id="id12" language="python" name="name"&gt;
def escape_for_xml(s):
    t = dict(zip([ord('&amp;lt;'), ord('&amp;gt;'), ord('&amp;amp;')], ['&amp;amp;lt;', '&amp;amp;gt;', '&amp;amp;amp;']))
    try:
        return s.translate(t)
    except AttributeError:
        return s
&lt;/codeblock&gt;
</code></pre>
<p class="p">Note that nothing is done to indicate that the contents of the codeblock are to be treated as preformatted. That is up to the <span class="phrase">application layer</span>.</p>
</div>
<div class="html-serialization">
<p class="p">For HTML output, the content of a codeblock is wrapped in an HTML <code class="code">pre</code> tag with the class attribute set to <code class="code">codeblock</code>. If the codeblock has a <code class="code">code_language</code> attribute, a <code class="code">data-language</code> attribute is added to the <code class="code">pre</code> tag containing the language value, and  the content is also wrapped in <code class="code">code</code> tags with the <code class="code">class</code> attribute set to the code language.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;pre class="codeblock" data-language="python" lang="en"&gt;&lt;code class="python"&gt;def escape_for_xml(s):
    t = dict(zip([ord('&amp;lt;'), ord('&amp;gt;'), ord('&amp;amp;')], ['&amp;amp;lt;', '&amp;amp;gt;', '&amp;amp;amp;']))
    try:
        return s.translate(t)
    except AttributeError:
        return s
&lt;/code&gt;&lt;/pre&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A codeblock in represented in the SOM with a <span class="phrase"><span class="annotation" data-annotation-type="object">Codeblock</span></span> object. The contents of the codeblock are represented as an <span class="phrase"><span class="annotation" data-annotation-type="object">Pre</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="embed">
<h2 class="title">Embedded markup</h2>

<p class="p">You can embed markup in other markup languages. Unlike a codeblock, the intended semantics of an embed are that the markup will be processed in the application layer. For example, a piece of latex math markup might be processed in the application layer to display an equation.</p>
<div class="syntax">
<p class="p">An embed works just like a <span class="phrase"><span class="annotation" data-annotation-type="object">codeblock</span></span>, except that there is an <span class="phrase">encoding</span> attribute on the block.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">```(=latexmathml)(*id13)(#name)(?a)(?b)
    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k
</code></pre>
</div>
<div class="semantics">
<p class="p">Embedded markup is intended to be processed by the application layer and the results of that processing to be displayed.</p>
<p class="p">Note that SAM knows nothing about the embedded markup and does not processes it in any way. It merely captures it and sends it on to the application layer.</p>
</div>
<div class="xml-serialization">
<p class="p">An <span class="phrase">embed</span> is serialized as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;embed conditions="a,b" id="id13" encoding="latexmathml" name="name"&gt;
n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k
&lt;/embed&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">In HTML output mode, the output of an embed is hidden by default. You could supply a javascript program to display the embedded data is needed.</p>
<p class="p">A block embed is serialized as a <code class="code">div</code>:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;div class="embed" hidden  data-conditions="a,b" data-encoding="latexmathml" id="id13" data-name="name"&gt;
n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k
&lt;/div&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A block embed is represented in the SOM as an <span class="phrase"><span class="annotation" data-annotation-type="object">Embedblock</span></span> object. The contents are represented as a <span class="phrase"><span class="annotation" data-annotation-type="object">Pre</span></span> object.</p>
<p class="p">An inline embed is represented in the SOM as a Code object with an  <span class="phrase"><span class="annotation" data-annotation-type="attribute">encoding</span></span> attribute.</p>
</div>
</div>
<div class="structure" data-name="blockquote">
<h2 class="title">Blockquote</h2>

<p class="p">A block quote is a quotation presented as a separate block rather than inline in a paragraph.</p>
<div class="syntax">
<p class="p">A blockquote is created by and appropriate indent followed by three <code class="code">"</code> or <code class="code">'</code> characters followed by optional <span class="phrase">attributes</span> and/or a <span class="phrase"><span class="annotation" data-annotation-type="object">citation</span></span>.</p>
<blockquote class="blockquote">
<cite>Mother Goose</cite>
<p class="p">The quick brown fox jumps over the lazy dog.</p>
</blockquote>
<p class="p">The contents of a blockquote is regular SAM markup, and thus can contain <span class="phrase">phrases</span> and <span class="phrase">annotations</span>.</p>
</div>
<div class="semantics">
<p class="p">A blockquote is just like any other block with the exception that it is allowed to have a citation. The material inside a blockquote is treated as regular SAM markup and is processed as such.</p>
</div>
<div class="xml-serialization">
<p class="p">A blockquote is serialized as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;blockquote conditions="foo"&gt;
&lt;citation type="citation" value="Mother Goose"/&gt;&lt;p&gt;The quick brown fox jumps over the lazy dog.&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>
</div>
<div class="html-serialization">
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;blockquote data-conditions="foo" class="blockquote"&gt;
&lt;cite&gt;Mother Goose&lt;/cite&gt;
&lt;p&gt;The quick brown fox jumps over the lazy dog.&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A blockquote is represented in the <span class="phrase">SOM</span> by a <span class="phrase"><span class="annotation" data-annotation-type="object">Blockquote</span></span> object. The content of a blockquote are regular SAM objects which are children of the <span class="phrase"><span class="annotation" data-annotation-type="object">Blockquote</span></span> object as normal for the children of any object.</p>
</div>
</div>
<div class="structure" data-name="line">
<h2 class="title">Line</h2>

<p class="p">A line is piece of text with fixed line endings, such as a poem. Lines are generally used in groups for a piece of text with fixed line endings.</p>
<div class="syntax">
<p class="p">To create a set of lines, precede each one with a pipe character followed by a space.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">| You gotta walk that lonesome valley,
| You gotta walk it by yourself,
| Nobody here can walk it for you,
| You gotta walk it by yourself.
</code></pre>
<p class="p">You can also add <span class="phrase">id</span>s or <span class="phrase">condition</span>s to lines. In this case, the opening parentheses of the annotation must follow the leading pipe character immediately, and the closing parenthesis must be followed by a space:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">|(#foo2) You gotta walk that lonesome valley,[*bing page 22]
| You gotta walk it by yourself,
|(?bar) Nobody here can walk it for you,
|    You gotta walk it by yourself.
</code></pre>
<p class="p">The entire line must be on one line in the source.</p>
<p class="p">All spaces after the first space following the pipe are considered significant and are retained on output.</p>
<p class="p">A line cannot have children.</p>
<p class="p">The text of a line is a normal SAM flow and is processed as such.</p>
</div>
<div class="semantics">
<p class="p">A line is a line of text with a fixed line break. Unlike a <span class="phrase"><span class="annotation" data-annotation-type="object">codeblock</span></span>, the contents of a line are a regular SAM <span class="phrase">flow</span>.</p>
</div>
<div class="xml-serialization">
<p class="p">A line is serialized as follows.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;line name="foo2"&gt;You gotta walk that lonesome valley,&lt;citation type="idref" value="bing" extra="page 22"/&gt;&lt;/line&gt;
&lt;line&gt;You gotta walk it by yourself,&lt;/line&gt;
&lt;line conditions="bar"&gt;Nobody here can walk it for you,&lt;/line&gt;
&lt;line&gt;   You gotta walk it by yourself.&lt;/line&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">A line is serialized as follows.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;pre class="line" data-name="foo2"&gt;You gotta walk that lonesome valley,&lt;/pre&gt;
&lt;pre class="line"&gt;You gotta walk it by yourself,&lt;/pre&gt;
&lt;pre class="line" data-conditions="bar"&gt;Nobody here can walk it for you,&lt;/pre&gt;
&lt;pre class="line"&gt;   You gotta walk it by yourself.&lt;/pre&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A line is represented in the <span class="phrase">SOM</span> as a <span class="phrase"><span class="annotation" data-annotation-type="object">Line</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="unordered-list">
<h2 class="title">Unordered List</h2>

<p class="p">An unordered list a piece of shorthand for a fully explicit unordered list structure.</p>
<div class="syntax">
<p class="p">An unordered list item is created by starting a paragraph with a <code class="code">*</code> followed by a space. Note that the space is require. Without it, the <code class="code">*</code> will be recognized as the beginning of a bold <span class="phrase">decoration</span>, or as plain text.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">* Dog
* Cat
* Monkey
</code></pre>
<p class="p">The text following the <code class="code">*</code> is treated as a <span class="phrase">paragraph</span>. This means that the ordered list above is equivalent to this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">ul:
    li:
        Dog
    li: 
        Cat
    li:
        Monkey
</code></pre>
<p class="p">and not this:</p>
<pre class="codeblock" data-language="SAM"><code class="codeblock" data-language="SAM">ul: 
    li: Dog 
    li: Cat 
    li: Monkey
</code></pre>
<p class="p">The only way to get the latter structure is to enter it as shown above.</p>
<p class="p">You can have more than one paragraph in a list item. To add a second paragraph, insert a space followed by a paragraph that is indented to the same level as the first letter following the <code class="code">*</code> of the list item:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">* How much is that doggy in the window.

  I hope that that fleabag's for sale. 

* Hey diddle diddle, the cat and the fiddle

  The cow jumped over the moon. 
</code></pre>
<p class="p">List can be nested. A nested list means that one list is the child of a list item in the parent list. To create this, indent the second list under an item of the first.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">* Dogs
    * Spot
    * Fang
* Cats
    * Mittens
    * Skimbleshanks
</code></pre>
<p class="p">Note that when an unordered list follows a paragraph, it must be a the same indent level as the preceding paragraph, not indented under it.</p>
</div>
<div class="semantics">
<p class="p">Unordered lists using this explicit concrete syntax are more limited than the lists you could create with explicit <span class="phrase">blocks</span> and fields. The only children a list item can have with this syntax are <span class="phrase">paragraphs</span> and nested <span class="phrase">unordered list</span>s or <span class="phrase">ordered list</span>s.</p>
<p class="p">Note that when an <span class="phrase">unordered list</span> follows a <span class="phrase">paragraph</span>, it is a sibling of that <span class="phrase">paragraph</span>. A list cannot be the child of a <span class="phrase">paragraph</span> since a paragraphs cannot have children.</p>
</div>
<div class="xml-serialization">
<p class="p">An ordered list is serialized as follows. Note that the content of a list item is always wrapped in a <code class="code">&lt;p&gt;</code> tag.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;ul&gt;
    &lt;li&gt;
        &lt;p&gt;Dogs&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;p&gt;Spot&lt;/p&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;p&gt;Fang&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p&gt;Cats&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;p&gt;Mittens&lt;/p&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;p&gt;Skimbleshanks&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">An ordered list is serialized as follows. Note that the content of a list item is always wrapped in a <code class="code">&lt;p&gt;</code> tag.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;ul class="ul"&gt;
    &lt;li class="li"&gt;
        &lt;p class="p"&gt;Dogs&lt;/p&gt;
        &lt;ul  class="ul"&gt;
            &lt;li class="li"&gt;
                &lt;p class="p"&gt;Spot&lt;/p&gt;
            &lt;/li&gt;
            &lt;li class="li"&gt;
                &lt;p class="p"&gt;Fang&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p class="p"&gt;Cats&lt;/p&gt;
        &lt;ul class="ul"&gt;
            &lt;li class="li"&gt;
                &lt;p class="p"&gt;Mittens&lt;/p&gt;
            &lt;/li&gt;
            &lt;li class="li"&gt;
                &lt;p class="p"&gt;Skimbleshanks&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">An <span class="phrase">unordered list</span> is represented by an <span class="phrase"><span class="annotation" data-annotation-type="object">UnorderedList</span></span> object. Each list item is represented by a <span class="phrase"><span class="annotation" data-annotation-type="object">UnorderedListItem</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="ordered-list">
<h2 class="title">Ordered list</h2>

<p class="p">An <span class="phrase">ordered list</span> a piece of shorthand for a fully explicit ordered list structure.</p>
<div class="syntax">
<p class="p">The syntax of an ordered list is the same as for an unordered list except that it uses one or more numerical characters followed by a period followed by a space:</p>
<pre class="codeblock" data-language="SAM"><code class="codeblock" data-language="SAM">0. Robot
12. Spaceship
7. Ray gun
</code></pre>
<p class="p">The numbers are not retained, nor is their style. The processing application will decide the style and numbering of lists.</p>
<p class="p">Ordered list items can have multiple <span class="phrase">paragraph</span>s and nested lists just like <span class="phrase">unordered lists</span>, and ordered and unordered list can be nested inside each other.</p>
</div>
<div class="semantics">
<p class="p">The semantics of ordered lists are the same as those of <span class="phrase">unordered list</span>, except, of course that the list is ordered.</p>
</div>
<div class="xml-serialization">
<p class="p">Identical to <span class="phrase">Unordered List</span> except with a <code class="code">ol</code> wrapper element.</p>
</div>
<div class="html-serialization">
<p class="p">Identical to <span class="phrase">Unordered List</span> except with a <code class="code">ol</code> wrapper element.</p>
</div>
<div class="SOM">
<p class="p">An unordered list is represented by an <span class="phrase"><span class="annotation" data-annotation-type="object">OrderedList</span></span> object. Each list item is represented by a <span class="phrase"><span class="annotation" data-annotation-type="object">OrderedListItem</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="labeled-list">
<h2 class="title">Labeled list</h2>

<p class="p">A <span class="phrase">labeled list</span> is a list in which each item has a label rather than a bullet of a number. They are a close analogue of HTML definition lists. The main difference is that definition lists have false semantics. They are not always used for definitions. So SAM labeled lists are named more accurately.</p>
<div class="syntax">
<p class="p">Labeled lists begin with a label between pipe characters. There must be no space between the opening pipe character and the start of the label text. (Otherwise it will be parsed as a <span class="phrase"><span class="annotation" data-annotation-type="object">line</span></span>, not a labeled list.</p>
<pre class="codeblock" data-language="SAM"><code class="codeblock" data-language="SAM">|fa| A long long way to run.
|so| A needle pulling thread.
|la| A note to follow so.
</code></pre>
<p class="p">As with other lists, the content of a list item is a <span class="phrase">paragraph</span> and you can add other structures after the initial paragraph by adding them at the same indent as the first paragraph. (The start of the paragraph, not the label.)</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">|Do| a deer,
a female deer
|Re| a drop of
     golden sun

     Is it a particle or a wave?


|Me| a name I call myself
</code></pre>
</div>
<div class="semantics">
<p class="p">A <span class="phrase">labeled list</span> is simply as list with a label instead of a bullet. There is no restriction built into the language as to what structures you can nest under a definition list item, but prudence would suggest that it would be appropriate to restrict things in the schema.</p>
</div>
<div class="xml-serialization">
<p class="p">A <span class="phrase">labeled list</span> is serialized as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;ll&gt;
&lt;li&gt;
&lt;label&gt;Do&lt;/label&gt;
&lt;p&gt;a deer, a female deer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;label&gt;Re&lt;/label&gt;
&lt;p&gt;a drop of golden sun&lt;/p&gt;
&lt;p&gt;Is it a particle or a wave?&lt;/p&gt;
&lt;/li&gt;
&lt;/ll&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A <span class="phrase">labeled list</span> is represented in the SOM by a <span class="phrase"><span class="annotation" data-annotation-type="object">LabeledList</span></span> object. Each item is represented by a <span class="phrase"><span class="annotation" data-annotation-type="object">LabeledListItem</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="grid">
<h2 class="title">Grid</h2>

<p class="p">Grids are an very simple table-like construct. They are not full tables which are complex <span class="phrase">document domain</span> beasts with potentially elaborate syntax. There are many ways to do <span class="phrase">tables</span> or semantically represent data that may be displayed in tables in SAM. Grids are meant for the simplest cases that have no <span class="phrase">document domain</span> or <span class="phrase">subject domain</span> semantics. They are just a tick tack toe board.</p>
<div class="syntax">
<p class="p">A grid is created by starting a line with three <code class="code">+</code> signs. These may be followed by <span class="phrase">block annotations</span>.</p>
<p class="p">Each row of the grid is on a separate line. Cells are separated by pipes. There is no pipe before the first cell or after the last. All rows must have the same number of cells.</p>
<p class="p">There is no concept of a header, no row or column spanning. A grid consists of rows and cells. Each cell contains a single <span class="phrase">flow</span>. Each row must be on one line of the source files. Cell contents are trimmed of leading and trailing whitespace. This allows you to align the pipes if you wish (though this is not required).</p>
<pre class="codeblock" data-language="SAM"><code class="codeblock" data-language="SAM">+++
    *Type*  | *Term*    | *Notes*

    feature | fragment  | bing

    feature | fragments | bang
</code></pre>
<p class="p">Management attributes are permitted on the grid, but not the rows.</p>
<pre class="codeblock" data-language="SAM"><code class="codeblock" data-language="SAM">+++(*foo #bar ?baz)
    *Type*  | *Term*    | *Notes*

    feature | fragment  | bing

    feature | fragments | bang
</code></pre>
</div>
<div class="semantics">
<p class="p">A grid is nothing more than a two dimensional grid of cells. If you want any more complex representation of a table, you need to find a different way to mark it up.</p>
<p class="p">Note that SAM is primarily intended for creating <span class="phrase">subject domain</span> languages and as such it does not provide native support for complex tables, which are document domain objects. <span class="phrase">Record sets</span> are the SAM-like way to represent real record data. To create document domain tables in SAM, you would need to create a table markup using <span class="phrase">blocks</span> and <span class="phrase">fields</span>. Another alternative would be to use <span class="phrase"><span class="annotation" data-annotation-type="feature" data-specifically="embedded markup">embedded</span></span> XML.</p>
</div>
<div class="xml-serialization">
<p class="p">Grids are serialized as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;grid&gt;
&lt;row&gt;
&lt;cell&gt;&lt;phrase&gt;&lt;annotation type="bold"&gt;Type&lt;/annotation&gt;&lt;/phrase&gt;&lt;/cell&gt;
&lt;cell&gt;&lt;phrase&gt;&lt;annotation type="bold"&gt;Term&lt;/annotation&gt;&lt;/phrase&gt;&lt;/cell&gt;
&lt;cell&gt;&lt;phrase&gt;&lt;annotation type="bold"&gt;Notes&lt;/annotation&gt;&lt;/phrase&gt;&lt;/cell&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;cell&gt;feature&lt;/cell&gt;
&lt;cell&gt;fragment&lt;/cell&gt;
&lt;cell&gt;bing&lt;/cell&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;cell&gt;feature&lt;/cell&gt;
&lt;cell&gt;fragments&lt;/cell&gt;
&lt;cell&gt;bang&lt;/cell&gt;
&lt;/row&gt;
&lt;/grid&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">Grids are serialized as tables:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;table class="grid"&gt;
&lt;tr class="row"&gt;
&lt;td class="cell"&gt;foo&lt;/td&gt;
&lt;td class="cell"&gt;bar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row"&gt;
&lt;td class="cell"&gt;baz&lt;/td&gt;
&lt;td class="cell"&gt;bat&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">Grids are represented in the SOM by a <span class="phrase">Grid</span> object and rows by <span class="phrase">Row</span> objects.</p>
</div>
</div>
<div class="structure" data-name="comment">
<h2 class="title">Comment</h2>

<p class="p">A comment is a extra-textual comment on the markup of the document similar to a comment in code or in XML.</p>
<div class="syntax">
<p class="p">A comment is created by starting a line with a <code class="code">#</code>. There is no support for multi-line comments or for comments within running text.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam"># This is a comment.
</code></pre>
</div>
<div class="semantics">
<p class="p">A comment is intended as a comment on the source file. To comment on the document as a document, use <span class="phrase">remark</span>s.</p>
</div>
<div class="xml-serialization">
<p class="p">A comment is represented in XML as an XML comment.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;!-- This is a comment --&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">A comment is represented as an HTML comment:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;!-- This is a comment --&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A comment is represented in the SOM with a <span class="phrase"><span class="annotation" data-annotation-type="object">Comment</span></span> object.</p>
</div>
</div>
<div class="structure" data-name="remark">
<h2 class="title">Remark</h2>

<p class="p">A remark is an editorial comment on the document text.</p>
<div class="syntax">
<p class="p">A remark looks like a blockquote except that is is introduced with three <code class="code">!</code> characters and takes a attribution attribute:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">!!!(Mark Baker) 
    This is a remark.
</code></pre>
<p class="p">The body of a remark is normal SAM so it can contain other SAM structures.</p>
<p class="p">Remarks can take a <span class="phrase">id</span> or <span class="phrase">language</span> attribute, but not a <span class="phrase">name</span> or <span class="phrase">condition</span> attribute.</p>
<p class="p">Remarks are a block structure. There is not provision for including a remark in the middle of a paragraph. Generally, speaking, placing a remark after the paragraph it remarks on should be sufficient, however, if you want to anchor a remark to a specific spot in a paragraph, you can do so by giving the remark an <span class="phrase">ID</span> <span class="phrase">attribute</span> and referring to it using a <span class="phrase"><span class="annotation" data-annotation-type="object">citation</span></span>:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This requires a remark[*cdg1], but the paragraph continues.

!!!(Charles Andr Joseph Marie de Gaulle)(*cdg1)(!fr)
    La Plume de ma tante.
</code></pre>
</div>
<div class="semantics">
<p class="p">Remarks are intended for communication between authors, editors, and reviewers during the preparation of the document. They may be presented in editors or in draft versions of output. They do not form part of the finished document.</p>
</div>
<div class="xml-serialization">
<p class="p">The XML representation of a <span class="phrase">remark</span> is as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;remark attribution="mbaker"&gt;
&lt;p&gt;This is a remark.&lt;/p&gt;
&lt;/remark&gt;
</code></pre>
<p class="p">Remarks anchored with a citation are serialized like this:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;This requires a remark&lt;citation type="id" value="*cdg1"/&gt;, but the paragraph continues.
&lt;remark attribution="Charles Andr Joseph Marie de Gaulle" id="cdg1" xml:lang="fr"&gt;
&lt;p&gt;La Plume de ma tante.&lt;/p&gt;
&lt;/remark&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">The HTML representation of a <span class="phrase">remark</span> uses a <code class="code">div</code> with the <code class="code">class</code> attribute set to <code class="code">remark</code>. The attribution is represented as a <code class="code">data-attribution</code> element:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;div class="remark" data-attribution="mbaker"&gt;
&lt;p class="p"&gt;This is a remark.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p class="p">HTML output mode will not render a unanchored citations, so the remark will not be connected to the anchor point in the paragraph in HTML output. A warning will be issued for the unanchored citation.</p>
</div>
</div>
<div class="structure" data-name="decoration">
<h2 class="title">Bold and italic decorations</h2>

<p class="p">A decoration is a shortcut for creating an annotated phrase. They are used for common text formatting features  bold, and italic. Decorations are shortcuts, so</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is in *important* type.
</code></pre>
<p class="p">is a shortcut for</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is {important}(bold).
</code></pre>
<div class="syntax">
<p class="p">Decoration are indicated by charters in the text that bracket phrases. The decorations are as follows:</p>
<ul class="ul">
<li class="li">
<p class="p"><code class="code">*</code> is a decoration for bold.</p>
</li>
<li class="li">
<p class="p"><code class="code">_</code> is a decoration for italic</p>
</li>
</ul>
<p class="p">Examples:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is in *bold* type.
</code></pre>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is _italic_ type.
</code></pre>
<p class="p">Decorations cannot be nested, so</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is *_important_*.
</code></pre>
<p class="p">is not a shortcut for</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is {important}(bold)(italic)
</code></pre>
<p class="p">but would be interpreted as</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is {_important_}(bold).
</code></pre>
<p class="p">Decorations are not recognized inside of <span class="phrase">phrase</span>s, since decorations are shorcuts for phrases and phrases cannot be nested. Decoration characters inside annotations are read as plain text.</p>
<p class="p"><span class="phrase"><span class="annotation" data-annotation-type="structure" data-specifically="annotation">Annotation</span></span> chaining is supported for decorations. Therefore if you want to make text both both and italic, you could use:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is *important*(italic)
</code></pre>
<p class="p">Although it may be clearer to do this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This text is {important}(bold)(italic)
</code></pre>
<div class="semantics">
<p class="p">In SAM, the bold and italic decorations are media domain structures calling for the use of bold and italic typefaces respectively. This is in contrast to most lightweight markup languages which use them (or similar markup) to mean an abstraction like "emphasis" or "strong". The problem with these abstractions is that their meaning in not clear. Bold and italic type are conventionally used for specific purposes and should not be abstracted out without some definite indication of the purpose. Thus in SAM, you would normally expect a tagging language that expected the titles of books to occur regularly in content would provide a suitable <code class="code">title</code> annotation to mark them up.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">{Moby Dick}(book) is about a whale.
</code></pre>
<p class="p">But if there the tagging language provides no such support, because books are not a significant subject for that language, then the writer who needs to mention a book should not be forced to use a vague and unreliable abstraction like <code class="code">emphasis</code> in order to ensure proper formatting of the title. They should be able to specify the correct media domain formatting choice:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">_Moby Dick_ is about a whale.
</code></pre>
<p class="p">Which is equivalent to:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">{Moby Dick}(italic) is about a whale.
</code></pre>
<p class="p">And we should note in this case that the abstract <code class="code">emphasis</code> is not only vague, it is actually incorrect. This is not a case of emphasizing a word, but of formatting a book title according to the commonly accepted convention. If you actually want an emphasis annotation in your tagging language, you should do it like this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">{Moby Dick}(italic) is a {very}(emphasis) good book.
</code></pre>
</div>
<div class="xml-serialization">
<p class="p">The bold and italic decoration are serialized as bold and italic elements respectively.</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;This text is in &lt;bold&gt;bold&lt;/bold&gt; type.&lt;/p&gt;

&lt;p&gt;This text is &lt;italic&gt;italic&lt;/italic&gt; type.&lt;/p&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">The bold and italic decoration are serialized as bold and italic elements respectively.</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;p&gt;This text is in &lt;b class="bold"&gt;bold&lt;/b&gt; type.&lt;/p&gt;

&lt;p&gt;This text is &lt;i class="italic"&gt;italic&lt;/i&gt; type.&lt;/p&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">The bold and italic decorations are represented in the SOM as bold and italic annotations using <span class="phrase"><span class="annotation" data-annotation-type="structure" data-specifically="annotation">Annotation</span></span> objects. No distinction is made between what were decorations in the source and what were annotations of the same name.</p>
</div>
</div>
</div>
<div class="structure" data-name="inline-code">
<h2 class="title">Inline code</h2>

<p class="p">Inline code is used to include code or data samples in the body of a paragraph.</p>
<div class="syntax">
<p class="p">Inline code is indicated by surrounding it in backticks:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In Python 3, use `print("Hello World")`. 
</code></pre>
<p class="p">The body of an inline code structure is not parsed for character escapes or other markup, so you can do this:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In SAM, a phrase looks like this: `{phrase}`.
</code></pre>
<p class="p">The only character that can be escaped in inline code is the back tick, which is escaped using a double back tick: <code class="code">`</code>.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In Python 3, use `print("Hello World")`(python). 
</code></pre>
<p class="p">Inline code can also take all the regular attributes.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">In the correct form is `print("Hello World")`(python)(?p3)`print "Hello World`(python)(?p2). 
</code></pre>
<p class="p">Inline code cannot take chained annotations, however.</p>
</div>
<div class="semantics">
<p class="p">The content of an inline code structure to presented as code, without interpretation. It may be formatted in accordance with its language.</p>
</div>
<div class="xml-serialization">
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;code language="sam"&gt;markup:&lt;/code&gt;
</code></pre>
<div class="html-serialization">
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;code class="code" data-language="sam"&gt;markup:&lt;/code&gt;
</code></pre>
</div>
</div>
<div class="SOM">
<p class="p">Inline code is represented in the SOM as an <span class="phrase">Phrase</span> object with an <span class="phrase"><span class="annotation" data-annotation-type="structure" data-specifically="annotation">annotation</span></span> of "code".</p>
</div>
</div>
<div class="structure" data-name="inline-embed">
<h2 class="title">Inline embed</h2>

<p class="p">An inline embed is a piece of embedded code that is intended to be interpreted by the application layer. For example, an inline embed could be used to embed an equation in latexmath.</p>
<div class="syntax">
<p class="p">An inline embed looks exactly like <span class="phrase">inline code</span> except that it has an annotation containing an encoding attribute, which it the name of the encoding language preceded by a <code class="code">=</code>:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(=latexmath) in the middle of a paragraph. 
</code></pre>
</div>
<div class="semantics">
<p class="p">The application layer should interpret the inline embed according to its language type and display the result.</p>
</div>
<div class="xml-serialization">
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;p&gt;This is an equation &lt;embed encoding="latexmath"&gt;\frac{ \sum_{t=0}^{N}f(t,k) }{N}&lt;/embed&gt; in the middle of a paragraph.&lt;/p&gt; 
</code></pre>
</div>
<div class="html-serialization">
<p class="p">An inline embed is serialized as a <code class="code">span</code> with the <code class="code">hidden</code> attribute:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;span class="embed" hidden data-encoding="latexmath"&gt;\frac{ \sum_{t=0}^{N}f(t,k) }{N}&lt;/span&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">An inline embed is represented in the SOM as a <span class="phrase">Code</span> object with an <span class="phrase"><span class="annotation" data-annotation-type="attribute">Encoding</span></span> attribute.</p>
</div>
</div>
<div class="structure" data-name="variable">
<h2 class="title">Variable</h2>

<p class="p">A variable is a way to store a value (specifically, a <span class="phrase">Flow</span>) that can be inserted into any part of a document. Variable definitions are scoped, meaning that you can locally override the value of a variable. This can be used to replace values in a block of text that is reused by reference.</p>
<div class="syntax">
<p class="p">A variable definition is created by the appropriate indent followed by a <code class="code">$</code> and a <span class="phrase">name-like-string</span> followed by an <code class="code">=</code> and the value of the variable. The variable value ends at the end of the current line:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">$foo = bar
</code></pre>
<p class="p">The variable can then be inserted using a <span class="phrase">block insert</span> or <span class="phrase">inline insert</span>:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">The sentence includes a string insert &gt;($foo).

&gt;&gt;&gt;($foo)
</code></pre>
<p class="p">Variable definitions do not take any <span class="phrase">attributes</span>. The variable name is a <span class="phrase">name token</span>.</p>
<p class="p">In XML output mode, the resolution of variables is left to the <span class="phrase">application layer</span>. This allows the application layer to consider variables definitions from outside the local file.</p>
<p class="p">In HTML output mode, variables are resolved using definitions in the local file. A warning is issued if the variable cannot be resolved and the insertion is skipped.</p>
</div>
<div class="semantics">
<p class="p">Within a local file, variable are local to the scope in which they are defined.</p>
<p class="p">When resolving a variable, the application layer should first look at any variable definitions that are children of the insert statement. If no matching variable definition is found, it should then work its way up the tree, looking in the parent structure and then the preceding siblings of the parent structure and so on to the document root. Note that this is not the same as searching in reverse document order, since it does not look in children of preceding siblings.</p>
<p class="p">The application layer is entitled to introduce variable definitions from outside the local file. Such variables should always be last in the search order for variable definitions. In other words, the most local definition always wins. System designers may want to consider imposing variable naming conventions to avoid accidental variable name conflicts.</p>
</div>
<div class="xml-serialization">
<p class="p">Variables are serialized as <code class="code">variable</code> elements:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;variable name="foo"&gt;bar&lt;/variable&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">Variables are serialized as <code class="code">span</code> elements with the <code class="code">hidden</code> attribute:</p>
<pre class="codeblock" data-language="html"><code class="codeblock" data-language="html">&lt;div class="variable" data-name="foo" hidden&gt;bar&lt;/div&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">Variables are represented as <span class="phrase">Variable</span> objects.</p>
</div>
</div>
<div class="structure" data-name="fragment">
<h2 class="title">Fragment</h2>

<p class="p">A fragment is a chunk of content that is set off so that it can be managed separately from the rest of the document. Reasons for creating a fragment could include making a chunk of the document conditional or available for reuse. A fragment is essentially a block of content that has no semantic identity of its own, but exists only to be managed arbitrarily, such as for ad hoc reuse of text that is not based on reusing a complete <span class="phrase">semantic block</span>. Examples include passages that are conditionalized for use in different contexts.</p>
<div class="syntax">
<p class="p">Fragments are created beginning a line with the <code class="code">~</code> characters:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">This paragraph is outside the fragment.

~~~(?foo)

    This paragraph is inside the fragment and should only appear if the {condition} `foo` is true.

This paragraph is outside the fragment again and will always be included.
</code></pre>
<p class="p">You can allow for the redefinition of parts of the text of a fragment by defining a variable inside a fragment and use that variable in the definition of the fragment text:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">~~~(#my-fragment) 
    $color=black 
</code></pre>
<p class="p">To insert a fragment:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&gt;&gt;&gt;(#my-fragment)
</code></pre>
<p class="p">As per the <span class="phrase">variable</span> scoping rules, any redefinition of those variable as children of the insert will override the values in the fragment. Thus:</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&gt;&gt;&gt;(#my-fragment)
    $color=white
</code></pre>
<p class="p">should be resolved to:</p>
<pre class="codeblock">Bar bar white sheep Have you any wool?
</pre>
<p class="p">(But remember that <span class="phrase">variable</span> resolution is performed by the <span class="phrase">application layer</span> in <span class="phrase">XML output mode</span> but by the SAM parser in <span class="phrase">HTML output mode</span>.)</p>
</div>
<div class="semantics">
<p class="p">The handling of fragments and strings belongs to the <span class="phrase">application layer</span>.</p>
<p class="p">Semantically, a fragment is just an arbitrary chunk of the document hierarchy. If it is inserted somewhere using an <span class="phrase">insert</span> with a <span class="phrase">idref</span>, <span class="phrase">nameref</span>, or <span class="phrase">keyref</span>, then the fragment is to be inserted at that location.</p>
<p class="p">If a fragment is reuse in this way, and if there are <span class="phrase">stringref</span>s in the body of the fragment, any strings defined in the fragment <span class="phrase">insert</span> override those defined in the fragment and any other string definitions of the same name.</p>
<p class="p">Fragments can be nested inside other fragments. Fragments can contain <span class="phrase">inserts</span> of other fragments. Circular fragment references are illegal but must be caught at the application layer.</p>
</div>
<div class="xml-serialization">
<p class="p">A fragment is serialized to XML as follows:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;fragment conditions="gruz-natz" name="foo3"&gt;
&lt;variable name="a"&gt;apple&lt;/variable&gt;
&lt;variable name="b"&gt;banana&lt;/variable&gt;
&lt;p&gt;This is a sentence inside a fragment.&lt;/p&gt;
&lt;/fragment&gt;
</code></pre>
</div>
<div class="html-serialization">
<p class="p">A fragment is serialized to HTML by wrapping it in a <code class="code">div</code> element with the <code class="code">class</code> attribute set to <code class="code">fragment</code>:</p>
<pre class="codeblock" data-language="xml"><code class="codeblock" data-language="xml">&lt;span class="fragment" data-conditions="gruz-natz" data-name="foo3"&gt;
&lt;span class="variable" data-name="a"&gt;apple&lt;/span&gt;
&lt;span class="variable" data-name="b"&gt;banana&lt;/span&gt;
&lt;p&gt;This is a sentence inside a fragment.&lt;/p&gt;
&lt;/span&gt;
</code></pre>
</div>
<div class="SOM">
<p class="p">A <span class="phrase">fragment</span> is represented in the <span class="phrase">SOM</span> by a <span class="phrase">Fragment</span> object.</p>
</div>
</div>
<div class="structure" data-name="include">
<h2 class="title">Include</h2>

<p class="p">You can include one SAM file in another. The included file must be a complete SAM file. Its structure is included in the structure of the included file at the indent level of the include statement. That is to say, the structures of the included file are treated as if they had their own indent plus the indent of the include statement.</p>
<div class="syntax">
<p class="p">An include is indicated by the appropriate indent, followed by three less-than signs, followed by the path to a SAM file in parentheses.</p>
<pre class="codeblock" data-language="sam"><code class="codeblock" data-language="sam">&lt;&lt;&lt;(foo.sam)
</code></pre>
</div>
<div class="semantics">
<p class="p">Unlike inserts, which are simply passed on to the application layer for processing, the file pointed to by an <span class="phrase">include</span> is parsed by the parser. The result of the include is presented to the application layer as part of the parsed document.</p>
<p class="p">The ID uniqueness constraint that applies to individual SAM document also applies to included files. The IDs must be unique across the entire document parsed from the source file and any included files.</p>
<p class="p">Includes cannot be made conditional, since conditions are parsed by the application layer and includes are processed by the parser.</p>
<p class="p">If you need to apply a condition to an include, place the include in a fragment and make the fragment conditional. This will result in the file being parsed and included in the output, but its content will be inside the fragment, making the whole thing conditional.</p>
<p class="p">For similar reasons, an include cannot have a <span class="phrase">name</span>, <span class="phrase">id</span>, or <span class="phrase">language</span> attribute, since the include instruction itself is not present in the output. If you need to apply any of these things to the included content, you can wrap the include statement in another structure such as a <span class="phrase">block</span> or a <span class="phrase">fragment</span> and apply the attributes to that. This will result in the included content being wrapped in that block or fragment in the output where the application layer can deal with it appropriately.</p>
</div>
<div class="xml-serialization">
<p class="p">Include instructions are not serialized on output. Their content resulting from processing the include is serialized as it would have been if it were entered inline.</p>
</div>
<div class="html-serialization">
<p class="p">Include instructions are not serialized on output. Their content resulting from processing the include is serialized as it would have been if it were entered inline.</p>
</div>
<div class="SOM">
<p class="p">The <span class="phrase">include</span> is represented in the <span class="phrase">SOM</span> by an <span class="phrase">Include</span> object. Thus it is possible when accessing the <span class="phrase">SOM</span> to tell whether or not the content was part of an included file. It is not possible to tell this in the serialized XML output.</p>
</div>
<div class="future">
<p class="p">There is a proposal to decorate the IDs occurring in an included file to ensure they do not overlap those of the including file. See issue <span class="phrase"><span class="annotation" data-annotation-type="issue">104</span></span>.</p>
</div>
</div>
</div>
</div>
</body>
</html>