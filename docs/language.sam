specification: Semantic Authoring Markdown (SAM)

    introduction:

        note:
            This document is a formal description of the SAM language. It describes the formalisms behind the syntax and it may make SAM sound a lot more complex to work with than it really is. If you just want to learn how to write in SAM, see the {SAM Quick Start}(document).

        Semantic Authoring Markdown (SAM) is a simplified markup for semantic authoring. Semantic authoring means writing texts that identify some part of their semantics thought embedded markup. Semantic authoring also places constraints on the author, making sure they create the content that is required. Semantic authoring allows for sophisticated validation and manipulation of content, supporting increased quality and improving the efficiency of the publishing process.

        SAM is a tale that grew in the telling. It was designed from the bottom up, not the top down, and so formalizing the language description comes after the fact. This document is a step along the way to a fully formal definition. There is not yet a full formal grammar for SAM. It is possible that the development of such a grammar could reveal ambiguities in the language definition that might require design changes in the future. 
        
        section: Why SAM?
        
            Why is SAM needed? What are the limits of current semantic authoring solutions? The core of a semantic authoring solution is a markup language. There are, broadly, two kinds of markup languages: general and lightweight. Lightweight markup languages are easier to use, but less capable. XML is the only general languages in common use today (thought SGML is also still in use). There are many lightweight markup languages. The best known is Markdown.
            
            The key issue for real semantic authoring is extensibility: the ability to specify your own semantics. (To create new tag that are specific to what you are writing about.)
        
            Current lightweight markup languages have fixed semantics with little or no extensibility. Where extensibility exists, it generally requires coding extensions to the parser. 
            
            XML supports extensibility through schemas. But the price it pays for this is an abstract data model and a verbose syntax. Writing and editing in XML is cumbersome, even with a dedicated XML editor (and dedicated XML editors can be expensive). And while XML is intended for doing structured writing, in practice it tends to hide the structure of the content either behind a WYSIWYG editing interface or verbose markup.
            
            SAM attempts to bridge these two worlds, providing a lightweight syntax that is easy to read, write, and edit, and which makes the structure of the content clear and explicit. SAM is also designed to be extensible and to support the specification of new tags through a schema. (Currently the SAM Parser uses an XML schema language to validate the output XML, but a true SAM schema language is planned.)
            
            Most lightweight markup languages provide a fixed set of document structures with little or no extensibility. XML provides no document structures by default and makes you specify everything in a schema. SAM defines a limited set of core text structures such as paragraph and lists and then leaves it to you to specify the semantic structures that contain the text.

            It is important to note that SAM is not designed as a language for text representation. That is, it is not a language designed for taking an existing text, and, without violence to that text, adding metadata to explicate its meaning or structure. For that you need a form of markup with the ability to clearly delineate in-band and out-of-band data. XML provides this by consigning in-band data (the text of the document) to the textual content of elements, and out-of-band (metadata describing the document) to attributes. SAM defines a few preset management attributes but provided no facility for creating new ones. Any additional metadata you want to add to a block, for instance, has to take the form or fields. This muddies the distinction between in-band and out-of-band information. For content creation, this is entirely appropriate, and the whole element/attribute distinction is tedious and confusing. If you are looking for a markup language that is designed so that you can simply remove the markup and be left with the original document, SAM is not the right choice.

        section: Processing model
        
            SAM is a cross between an abstract or meta language like XML and a concrete language like MarkDown. XML does not describe the semantics of any of the tagging languages you base on it. The XML parser does not implement any markup semantics. Implementing semantics is left to the application layer -- another program or set of program that process the output of the parser. In many XML-based tool chains, the application layer is written in XSLT. Markdown describes the entire semantics of the language. The Markdown processor executes the entire semantics of the language, producing HTML output directly from Markdown. It does not require a separate application layer.
            
            SAM follows the XML model. The SAM parser simply reads the SAM markup and extracts its structures. It does not interpret the semantics of the document, but leaves that to the application layer.

            A SAM parser may make the structure of a SAM document available to the applications layer in different ways. It can expose the structure via an API and/or it may output an XML representation of the structure of the SAM document.
            
        section: Semantics

            While the SAM parser does not act on the semantics of the document, deferring that to the application layer, it contains concrete markup which the writer is entitled to expect will be processed in a particular way. These are the intended semantics of SAM structures. The application layer is expected to honor and implement the semantics of SAM markup.

            A lot of SAM's concrete markup is simply shortcuts for common writing structures like lists. The exact same structures could be created using blocks, fields, and paragraphs, and you can create variant structures (other types of lists, for example) using these standard components. However, some of SAM's concrete markup expresses a particular view about markup language design. For example, it use of annotations and citations expresses a particular view about how text inside paragraphs should be marked up. Since SAM does not provide other facilities to create markup in paragraphs, it may not be suitable for expressing all types of markup language design. SAM is not, and is not intended to be, a full replacement for XML.

        section: SAM Structure

            Like all other markup languages, a SAM document is essentially a set a set of nested blocks of various types. In concrete markup languages like markdown there are a fixed set of block types, each with a specific meaning, and each with a corresponding piece of syntax that allows the parser to identify them. In an abstract markup language like XML, there are a few abstract block types that have no inherent meaning, but can be named so that a processing application can attach meaning to the name in specific markup languages. Thus a paragraph is represented with a `<p>` element in HTML but by a `<para>` element in DocBook. 

            As a hybrid language, SAM has a set of concrete block types, each with its own semantics and syntax, and a set of abstract nameable block types that can be used to define additional semantics for specific SAM-based markup languages. Thus in SAM a {paragraph} is always created as a block of text, but you can create named blocks to capture things like `author-name:`.  

            Blocks may contain flows. A flow is a data value, the contents of a block, but a flow can also contain other structures. This is also a common feature of document markup languages. In HTML, for instance, you can have an `<a>` element in the middle of a paragraph to create a link. XML-based languages, including HTML, use elements for structures within a flow (creating something called mixed content). In SAM, structures within a flow are distinct from blocks and have a different syntax.

            Four kinds of structures can exist in a flow, a {phrase}, an {insert}, and a {citation}. However, a {phrase} can be annotated to indicate its semantics, which makes {phrase}s an extensible feature of SAM. 

            The following example shows a {paragraph} with two annotated {phrase}s.

            ```(sam) 
                In {Rio Bravo}(movie), {the Duke}(actor "John Wayne" (SAG)) plays a union colonel.



        section: SAM Syntax
            
            Syntactically, SAM takes its cues from YAML and Python (for displaying overall structure), from Markdown (for displaying text structures) and from common English usage (for displaying annotations.) In contrast to some of the richer lightweight markup languages, it tries to minimize the use of exotic forms of punctuation to delineate structures. 
            
            The intention is that an author writing in SAM should feel no need to use a visual editor, but should work directly in raw SAM (albeit with editor-supplied syntax coloring if desired). A SAM document should be a very natural read. 

            SAM is not designed to be a full replacement for XML. It is far less general, because of its use of predefined syntax for common text structures such as lists and paragraphs, and it has very limited support for attributes. Basically, each structure has a fixed set of attributes available. There is no extensibility for attributes. This is essential to maintain the readability of SAM sources, but it limits certain styles of markup design.
            
            In particular, SAM is designed to support a declarative approach to semantic authoring meaning that it is designed to express declarations about the structure of the document and the meaning of the text, rather than to embed management and processing information into the source, a practice common in many structured authoring languages. 

            Document-oriented markup languages such as reStructuredText and Markdown tend to be very flat in structure. One things follows another. There is rarely a case where one thing is inside another. For example, these languages use heading levels, but don't delineate sections of the document. More semantically rich languages tend to be more hierarchical, with one structure inside another. For example, a document might be divided into sections with title and paragraph elements inside a section. This means that you need to show which structures are inside others and where the containing structure ends. 

            XML does this by having an explicit end tag for every element. A large part of the verbosity of XML comes from its requirement to close every element tag. Many programming languages, which similarly have to express nested structures, use some form of brackets to delineate each structure. Python is an exception to this. It uses indentation to express the relationship between structures. This is a far more natural way for writers to express the subordination of elements -- one that is sometimes also used in published works. SAM uses this approach and avoids the use of end tags entirely.

            SAM syntax defines the following structures:

            |named block| Named blocks are structures that contain other structures. For instance, a section is a block. Blocks must have names. Named blocks (and named fields) are how you introduce new structures into a SAM document. Named blocks may be referred to a "blocks" in this document, but all of SAMs concrete block types are also blocks.

            |field| Fields are named blocks that contain individual values. For instance, the date a document  is usually a field.

            |flow| A flow is a string of text. All text content in a SAM document constitutes a flow. A {paragraph} is a flow. The {value} of a field is a flow. A {title} is a flow. Etc. Flows can contain {phrases}, {citations}, and {inserts}.

            |paragraph| A paragraph is a continuous block of text across one or more contiguous lines. The content of a paragraph is a {flow}.

            |phrase| A phrase is a string of characters in a flow. You use a phrase when you want to attach an annotation or a citation to a string of text.

            |string| Strings are named pieces of text that can be included by reference in other parts of a document or in other documents.

            |annotation| Annotations are metadata attached to a phrase.

            |attributes| Attributes are metadata attached to a block. There are a very limited set of attributes with specific rules for where they can appear. For most of the purposes for which you would use attributes in XML, you should use fields in SAM.

            |block insertion| Block insertions are an instruction to the application layer in content from an internal or external source at the block level.

            |flow insertion|  Flow insertions are an instruction to the application layer in content from an internal or external source at the flow level (that is, inside a flow).
            
            |citations| Citations are references to other works or structures.
            
            |embedded XML| You can embed XML in a SAM document. 
            
            |include| You can include one SAM file in another.

            |ordered list| An ordered list is as list in which the order of the items is meaningful. An ordered list is any sequence of one or more ordered list items.

            |unordered list| An unordered list is a list in which the order of the items is not meaningful (as least as far as markup semantics is concerned). A unordered list is any sequence of one or more unordered list items.

            |labeled list| A labeled list is a list in which each item has a label (rather than a bullet or a number). A labeled list is an sequence of one or more labeled list items. A labeled list item consists of a label and a single paragraph.

            |line| A line is a single line of text, as in a poem, with a fixed line end. The contents of a line is a {flow}.

            |record set| A record set is a simple database table with named columns. It allows you to capture tabular data at a semantic level rather than at the presentation level of a table.

            |grid| A grid is a simple table-like layout structure.

            |fragment| Fragments are sections of a documents (potentially larger than a single paragraph) that can be included by reference in other parts of a document or in other documents. Strings used in a fragment can be redefined when a fragment is reused, allowing you to vary the text of the fragment when it is used in different places. (Note that this is describes the {presumed semantics} of fragments. Implementation of these semantics is up to the application layer.

            |comment| A comment on the SAM markup file itself, as opposed to a comment on the document. For comments on the document, use remark

            |remark| A remark is a comment on the text of the document, intended for editorial purposes. It must be attributed to a specific author.

        section:(#name) Names

            A name in a SAM document must be a valid XML local name. 

        section:(#name-like-string) Name-like string

            A name like string is a string that looks like a name. Name-like strings are used in parsing SAM files to detect the intention of the author to create a name. Not all name-like-strings are valid names. If the parser sees a name-like-string that is not a valid name, it reports an error. 

            The reason for recognizing name-like-strings rather than only recognizing valid names that otherwise, what the writer intended as a name might not be recognized as such and would therefore be treated as plain text, without any error or warning being raised. 

            By recognizing name-like-strings the parser is able to report an errors on these dubious cases, which reduce the likelihood or misinterpreting the author's intent. In the case where the name-like-string is indeed intended to be interpreted as plain text, the writer can ensure it is interpreted as such by escaping the concluding colon with a backslash. 

        section:(#syntax) Syntax

            A {block} in SAM is formed by starting a line with a name followed by a colon:

            ```(sam)
                description:
                    This is the content of a block named "description".

            Structures in SAM can contain other structures. The hierarchy of structures in SAM is defined by indentation. In the example above, the paragraph structure is inside the block named description because it is indented under it. 

        section:(#SOM) SAM Object Model

            The SAM Object Model is a way of representing the structure of a SAM document as a data structure to a computer program. The SAM object model is a way for program to access a SAM document in a standard way. Unless you are concerned with writing programs to access the SAM Object Model you can ignore all references to it in this document. The SAM Object model is the model implemented by the current SAM parser, which is written in Python. However, SAM parsers are not required to implement the SAM Object Model. 

            The other way for applications to access the structure of is by serializing it to XML. This is the only require access method for parsers to implement.

            Like the language itself, the SOM is a tale that grew in the telling. In the absence of a full formal grammar for SAM, the object model must be considered provisional. It should be considered a less stable interface to a SAM document than the canonical XML serialization. 
        
        section:(#parser) Parsing

            A SAM document may be interpreted by a SAM parser to form an object tree in memory, which can include the {SAM object model} or any standardized XML representation such as SAX or DOM. In these cases, the DOM or SAX interface should represent the standard XML serialization, or an optional variant of that serialization, not the SOM. A SAM parser must offer the option of serializing the document as XML. A SAM parser may offer various methods of serializing XML, but it must default to the serialization described in this document. 

    structures:
        The following is a list of the structures of a SAM document.

        structure:(#root) Root
            Every SAM document has a root which contains the entire content of the document. The root can contain a single block which is the parent of all other blocks in the document. This block is called the {root block}.  

            syntax:
                The {root} had no syntax of its own. It is an implicit container for the contents of the file. 

            semantics:
                None. The root is just a container.

            model:
                The {root} can contain the following, in order:

                * One or more {declaratiom}s.
                * One of more {comment}s, {remark}s, or {string definition}s.
                * The {root} block.
                * One of more {comment}s, or {remark}s.

            serialization:

                None. Only the children of the root are serialized.

            SOM:
                The {root} is represented by a {Root}(SOM_object) object that is created automatically by the parser when parsing starts. 
            
                All {declarations}, {comments}, {remarks}, and {string definitions} prior to the root block, and the root block itself, are children of the {Root} object. 

                Note that the SOM {Root} object is not the same thing as the root block. The {Root} object is a container for all the structures declared at column zero in the SAM document. The {root block} of the document itself is the only {block structure} permitted as a direct child of the {Root} object. 

        structure:(#root-block) Root block

            The {root block} is the first structure declared in the document after any {declaration}s, {comment}s, {remark}s or {string definition}s. It is the container for all other blocks in the document. 

            Any type of {block} can be the {root block}. However, choosing a structure other than a {named block} as the root block will be extremely limiting, as most {concrete block} types allow for little of no nesting of other blocks. For instance, nothing can be nested under a {paragraph} so while a paragraph can be the root block of a SAM document, it would also be the only structure in the document. 

            syntax:
                The {root block} is not indented. All other structures in the document must be children of the {root block}, and therefore must be indented under it. In all other respects, the syntax of the root block are the syntax of it root type. 

            semantics:

                The {root block} determines the type of the SAM document (just as the root element name in XML forms the type of an XML document). In all other respects, the semantics of the {root block} are no different from the semantics of that structure type. 

            serialization:

                The {root block} is serialized according to its block type. In addition, however, if a namespace is declared for the document, the appropriate namespace declaration will be added to the root element generated. 

            SOM:
                The root block is the only block child of the {Root} object. In every other respect, it is represented as its normal block type.


        
        structure:(#declaration) Declaration

            A SAM file may start with one or more declarations. A declarations gives the SAM parser information it needs to correctly parse the file. Declarations do not become part of the output.

            syntax:
                Declarations must come before all other content. A {declaration}(structure) is created by a line beginning with  an exclamation mark followed by an declaration type followed by a colon.

                ```(sam) 
                    !namespace: http://spfeopentoolkit.org/sam/ns/tests

            semantics:
                A declaration is a and instruction to the parser on how to interpret the SAM document. Declarations are not part of the content of the document described by the SAM markup. Rather, they describe the markup itself.    

                Currently the only declaration supported is the namespace declaration which sets the namespace for the entire SAM document. You cannot assign namespaces to individual structures in the text of a SAM document like you can in XML.

            future:
                The schema declaration specifies the location of a schema file. The location will be processed through an XML catalog if one is specified to the parser. If a schema is specified, the namespace declaration is ignored and namespaces are assigned per the schema. A schema may assign different elements to different namespaces.

                ```(sam) 
                    !schema: http://spfeopentoolkit.org/schemas/think-plan-do-topic.sams

            serialization:
                The namespace declaration causes the namespace of a document to be set to the specified namespace. This will result in the appropriate namespace declaration in the serialized XML file. A parser may handle namespace prefixes in any way it sees fit. 

            SOM:
                The namespace declaration is used to update the namespace property of all blocks. In future, the namespace property of blocks may be set by the schema. 


        structure:(#block) Named Block

            A {named block} is an abstract structure which allows you to extend SAM to express many different document structures. The name of a {named block} must be a valid {SAM name}.

            syntax:

                A named block is indicated by the appropriate indent followed by a {name-like string}, followed by a colon:

                ```(sam)
                    movie-review:

                To be considered a block, rather than a {field}, a {block} must have children. Children can be any other block types:

                ```(sam)
                    movie-review:
                        movie: Rio Bravo
                        stars:
                            star: John Wayne

                The example above contains two blocks (`movie-review` and `stars`) and two {fields} (`movie`) and (`star`).

                A named block can have a value:

                ```(sam)
                    movie-review: Rio Bravo is Classic Western

                Here the string "Rio Bravo" is the value of the block. The value of a block is regarded as the title of document section formed by a block, and is serialized as such. 

                A named block can have attributes. Attributes are metadata on the block. Attributes are contained in parentheses that follow the colon with no space:

                ```(sam) 
                    name:(?BC) Fred Flintstone

                A block can have multiple attributes, one after another, with no spaces between:

                ```(sam) 
                    name:(?BC)(#fred) Fred Flintstone 

                Unlike XML, SAM does not support arbitrarily named attributes. Only a fixed set of management attributes are supported. Each type is indicated by a different prefix character. 

                There are four types of management attributes:

                * {Conditions}(feature), which start with a `?`
                * {Name}(feature), which start with `#`
                * {ID}(feature), which start with `*`
                * {Language}(feature), which start with `!`

                A block can also have a title:

                ```(sam) 
                    section:(?ultra)(#ultra) The ultra feature is really cool!
                
                If there is any value after the colon and the attributes, it is considered a title for the {block} and generates a title structure. There must be a space between the colon or the closing parenthesis and the value.


                Blocks have children. To be considered a {block}, a structure must have children. That is, it must have other structures indented underneath it. If it has no children, it is interpreted as a {field}.


            semantics:
                The title of a a {block} is treated as the title of a the entire content of a {block}, and will be serialized as such. 

                Structurally, the title of a {block} is its value, in just the same way that the content of a field is its value. 

                It should be noted that the lack of arbitrary named attributes does not reduce the semantic flexibility of SAM as compared to XML. Any metadata that can be expressed by an attribute on a block can also be expressed by a field that is a child of that block. The reason for using attributes in XML is to preserve a pure distinction between text and metadata, but that is not a design consideration in SAM, which is meant for the creation of new text through structured writing, not for the annotation of existing texts for study.

            serialization:
            
                Thus the SAM markup above would create the following XML output:
                
                ```(xml)
                    <section conditions="ultra">
                        <title>The ultra feature is really cool!</title>
                        ...
                    </section>
                
            SOM:
                The representation of a block in the {SOM} is identical to the representation of a field. A block is distinguished from a field in the SOM by whether or not it has children. 
        
        structure:(#field) Field
        
            A field is named structure with a single value. Fields take the same attributes as {block}s.  

            syntax:
            
                A field is syntactically identical to a {block}. It is simply a block with no children:

                ```(sam)
                    name: Fred Flintstone
                    address: Bedrock
                    era: BC

            semantics:

                A {field} is essentially a way of creating a key-value pair in a document. 

            serialization:
                    
                A field is serialized as an XML element. The field content is the data content of the XML element. The name of the XML element matches the name of the field. Thus the example above would be serialized as:
                
                ```(xml)
                    <name>Fred Flintstone</name>
                    <address>Bedrock</address>
                    <era>BC</era>

            SOM:
                A {field} is represented by a {Block} object. The only difference between a {block} and a {field} is whether it has children. If it has children, it is a {block}. If not, it is a {field}. 

                This design is mostly to make parsing easier. When we see a {field} definition in a file we can't tell without looking ahead whether it is going to have children or not. Therefore we treat it as a {block}. The difference between a {field} and a {block} really only occurs on serialization, where the content of a {field} is simply its text value, whereas the content of a {block} is treated as a title and output as a `<title>` element. 

                Programs accessing the {SOM} directly should note that the value of a {block} should be treated as the title of that {block}.

                The value of a {field} is contained in a {Flow} object.

        structure:(#flow) Flow

            A {flow} is a section of document text in a SAM document. A {flow} can contain intra-textual structures like {annotation}s, {decorations}, and {inline insert}s.  

            syntax: 
                There is no special syntax to define a {flow}. Flows are defined by their relationship to other structures. 

            semantics:
                The text in a {flow} is simply text, along with any intra-textual structures it contains. 

            serialization:
                The flow object is not represented as an object in XML. Its content becomes the content of whatever element is created to represent the structure that contains the flow.

            SOM: 
                A {flow} is contained in a {Flow} object.

        structure:(#paragraph) Paragraph 

            A paragraph is a block of text. (SAM) has no opinion on whether the block of text would be considered a paragraph in grammatical or literary terms. As far as SAM is concerned, it is simply a block of text set off from other blocks of text and other structures. (This is identical to the meaning of paragraph in most markup languages.)

            The entire content of a paragraph is a single {flow}.

            syntax:

                A paragraph is indicated as sequence of lines ending with a blank line.

                ```(sam)
                    Now is the time
                    for all good men
                    to come to the aid
                    of the party.
                    
                    It was the best of 
                    times, it was the 
                    worst of times.

                Any line that in the source that is not identified as a different structure, or an attempt to create a different structure, is identified as a paragraph. 

                In some cases a paragraph may begin with a sequence that looks like an attempt to create a different structure. For instance, if there is a colon before the first space in a paragraph, and if the string before the colon is a name-like-value, then the writer can prevent the sequence being recognized as a {block} or {field} by escaping the colon with a backslash or a {character escape}.

                Once the first line of a paragraph has been identified, the parser simply accumulates subsequent lines, without looking for other structures, until one of the following is encountered:

                * A blank line.
                * A line whose indent is less than the indent of the first line of the paragraph.
                * If the paragraph is the child of a list item, the start of a new list item.

                A paragraph cannot have block children. Is is an error is any structure is indented under a paragraph. 

                note: 
                    Some writers may instinctively indent a list under the paragraph it follows. This is an error in SAM. A list is always the peer of the preceding paragraph is SAM and as such the list items must start at the same indent level as the preceding paragraph. The output formatter may, of course, choose to indent lists relative to their sibling paragraphs.  


            semantics:
                A paragraph is block of text.

            serialization:
                    
                A paragraph is serialized as a XML `p` element. Thus the example above would be serialized as the following XML:
                
                ```(xml)
                    <p>Now is the time for all good men to come to the aid of the party.</p>
                    
                    <p>It was the best of times, it was the worst of times.</p>

                A paragraph cannot have block children. It is a syntax error to have anything indented under a paragraph.  

            SOM: 
                A paragraph is represented by a {Paragraph} object with a single child {Flow} object.
                

        structure:(#phrase) Phrase

            A phrase structure is a delineated string of text within a {flow}. You create a phrase in order to add an {annotation} or {citation} to a word or phrase in the text. 

            syntax:
                A phrase is indicated by surrounding the phrase with curly braces:

                ```(sam) 
                    In {Rio Bravo}, {the Duke} plays a union colonel.

                It is not an error to have a phrase with no {annotation}s or {citation}s attached. When such as phrase is found, the parser must:

                * First, look backward through the document to find out if the same phrase has been annotated before. If it finds the same phrase, with an annotation, it copies the entire phrase and all attached {annotation}s and {citation}s to the current phrase. The search proceeds in reverse document order and stops at the first instance found. 

                * Second, if no matching phrase is found, the parser must issue a warning for the unannotated phrase.

                The search is conducted on a strict literal string basis, and is case sensitive.  

            semantics:
                A phrase has no semantics of its own. Its semantics are determined by any {annotation}s attached to it. 

            serialization:
                A phrase is serialized as an `phrase` element in XML.

                ```(xml) 
                    <p>In <phrase>Rio Bravo</phrase>, <phrase>the Duke</phrase> plays a union colonel.</p>

            SOM:
                A phrase is represented by a {Phrase} object.



        structure:(#annotation) Annotation

            Annotations clarify what a piece of text is about.  

            syntax:
                An {annotation} is attached to a phrase and is expressed as an expression in parentheses following the closing `}` of the phrase with no space in between. 

                An {annotation} consists either of one of four management attribute types (language, id, name, condition) or an {annotation} type expression. 

                An attribute annotation looks like this:

                ```(sam)
                    In Quebec, a stop sign says {arrÃªt}(!fr).


                An annotation type expression is an expression that specifies the type of a string. Here the type expression says that the string "Rio Bravo" is a reference to a movie: 

                ```(sam) 
                    In {Rio Bravo}(movie), {the Duke}(actor "John Wayne" (SAG)) plays a union colonel.


                There are three parts to an annotation type expression: 

                |type| The first word immediately following the opening parentheses is the type of the subject being annotated. In the sample above, "Rio Bravo" is a movie and "the Duke" is an actor. An annotation type must be a valid SAM {name}. The annotation type is required.

                |specifically| In some cases, the annotated text may not specify its subject clearly. In this case, the specifically attribute is use to clarify what is meant. The specifically attribute is a string in double or single straight quotes. In the sample above, "the Duke" means, specifically, "John Wayne". The specifically attribute is optional.

                |namespace| In some cases, it is necessary to specify the namespace to which the annotated term belongs. The namespace attribute follows the specifically attribute (if specified) and is contained in parentheses. In the sample above, the name of the actor "John Wayne" is part of a set of names managed by the Screen Actors Guild which makes sure two actors don't use the same stage name. (In most cases, the namespace is implied by the type, so you will not usually need to specify it.) The namespace attribute is optional.

            semantics:
                The specific semantics of individual annotation depend on the language designer, however, in order to maintain consistency across languages, it is important to use the specifically and namespace attributes for their intended purposes and not to hijack them to express some other semantics. 

                Type annotations may be from any of the structured writing domains (media, document, subject, management). The relationship between the annotation type and the meaning of the specifically attribute changes in each domain. 

                In the media domain, the annotation type refers to some media property to be applied to the text, and the specifically attribute supplies more specific information. For example it could be `{the Duke}(highlight "yellow")` or `{the Duke}(link "http://JohnWayne.com")`.

                In the document domain, the annotation type refer to some document property, and the specifically attribute supplies more specific information. For example, it could be `{the Duke}(index "Wayne, John")`.

                In the subject domain, the annotation type refers to the type of the subject being referred to and the specifically attribute clarifies the intended subject if required. For example `{the Duke}(actor "John Wayne").

                The key to using the annotation attributes correctly is simply to make sure that the attribute names apply in a reasonable fashion to the values they contain. If they don't, a different markup strategy should be used. 

                The semantics of management attribute annotations are as follows:

                * {condition}(attribute) determines if the {phrase} will be included in the output or not.
                * {Name}(attribute), assigns a {name} to the {phrase} so it can be referred to elsewhere.
                * {id}(attribute), assigns an {ID} to the {phrase} so it can be referred to elsewhere.
                * {language}(attribute), specifies the language in which the phrase is written. 




            serialization:

                An annotation is serialized as an `<annotation>` element. The type, specifically, and namespace attributes become attributes with those names in XML. 

                The `<annotation>` element is wrapped inside the `<phrase>` element that it annotation, with the content of the phrase on the inside.

                ```(xml) 
                    <p>In <phrase><annotation type="movie">Rio Bravo</annotation></phrase>, <phrase><annotation type="actor" specifically="John Wayne" namespace="SAG>the Duke</annotation></phrase> plays a union colonel.

                When a phrase has one or more annotations, those annotations are wrapped inside the `<phrase>` element in the order in which they occur in the source document. Thus the following:

                ```(sam)
                    The film starred {John Wayne}(actor)(director), who also directed.

                would be serialized as:

                ```(xml)
                    <p>The film starred <phrase><annotation type="actor"><annotation type="director">John Wayne</annotation></annotation></phrase>, who also directed.

            SOM:
                An annotation is represented in the {SOM} by an Annotation object. 


        structure:(#insert) Inserts

            An insert is an instruction to the {application layer} to insert a resource into the document output.

            Inserts may be created at the {block} level or inside a {flow}. 

            syntax:

                At the block level, an insert is placed
                on a line by itself and is indicated by three greater-than signs:

                ```(sam)
                    >>>(image foo.png)

                Inside a {flow}, an insert is indicated by a single greater-than followed the the identification of the
                resource in parentheses:

                ```(sam)
                    My favorite flavor of ice cream is >($favorite-flavor).


                The resource to be inserted may be identified either by type and URL as in the block example above or by
                reference to an {id}, {name}, {fragment}, {string}, or {key} as in the flow example.


                You can also assign {name}s, {condition}s, or {id}s to an insert. For example, to insert a fragment containing
                the introduction to the deluxe version of a product, you could do this:

                ```(sam)
                    >>>(~deluxe-intro)(?model=deluxe)

                Remember that it is up to the application layer to implement such inserts.

                You can use any name you like for the insert type, however the following types are reserved so that editors can act on them to provide enhanced views of the document while editing:

                * image
                * video
                * audio
                * feed
                * app

                They should be used only with their natural semantics.


            semantics:

                The insert is an instruction to the application layer to insert the specified resource. While implementation is entirely up to the applications layer, SAM specifies the semantics of the reserved insert types as follows:

                |"image"| Insert the graphic image into the output.
                |"video"| Insert the video into the output.
                |"audio"| Insert a playable audio clip into the output.
                |"feed"| Insert the result of a feed into the output.
                |"app"| Insert an embedded app into the output. 
                |a SAM {ID}| Insert the resource pointed to by the {ID} in a manner appropriate to its type.
                |a SAM {name}| Insert the resource pointed to by the {name} in a manner appropriate to its type. 
                |a SAM {fragment}| Insert the content of the {fragment} into this location in the document, and process any structures it contains. 
                |a SAM {string}| Insert the value of the string variable into the document, and process any structures it contains.
                |a SAM {key}| Insert the resource pointed to by the {key} in a manner appropriate to its type.

                Note that you are not obliged to use any of these types in order to do their assigned functions. You can devise any insert types you like, since responsibility for implementing them rests entirely with the application layer. The constraint is that you should not assign other semantics to these names. Having a standard set simply allows for editors to presume the semantics of the basic types and act on them if they wish.


        structure:(#include) Includes

            You can include one SAM file in another. The included file must be a complete SAM file. Its structure is included in the structure of the included file at the indent level
            of the include statement. That is to say, the structures of the included file are treated as if they had their own indent plus the indent of the include statement. 

            syntax:

                An include is indicated by the appropriate indent, followed by three less-than signs, followed by the path to a SAM file in parentheses.

                ```(sam)
                    <<<(foo.sam)

            semantics:

                Unlike inserts, which are simply passed on to the application layer for processing, the file pointed to by the include is parsed by the parser. The result of the include is presented to the application layer as part of the parsed document.

                The ID uniqueness constraint that applies to individual SAM document also applies to included files. The IDs must be unique across the entire document parsed from the source file and any included files.

                Includes cannot be made conditional, since conditions are parsed by the application layer and includes are processed by the parser. 

                If you need to apply a condition to an include, place the include in a fragment and make the fragment conditional. This will result in the file being parsed and included in the output, but its content will be inside the fragment, making the whole thing conditional. 

                For similar reasons, an include cannot have a {name}, {id}, or {language} attribute, since the include instruction itself is not present in the output. If you need to apply any of these things to the included content, you can wrap the include statement in another structure such as a {block} or a {fragment} and apply the attributes to that. This will
                result in the included content being wrapped in that block or fragment in the output where the application layer can deal with it appropriately.

            serialization:
                Include instructions are not serialized on output. Their content resulting from processing the include is serialized as it would have been if it were entered inline. 

            SOM:
                The {include} is represented in the {SOM} by an {Include} object. Thus it is possible when accessing the {SOM} to tell whether or not the content was part of an included file. It is not possible to tell this in the serialized XML output.

        structure:(#citation) Citations 

            Citations are any reference to another resource. This includes internal references to other structures within the document, such as to a graphic,procedure, or footnote, as well as references to external works.

            syntax:

                A citation is created using square brackets:

                ```(sam) 
                    Moby Dick[Melville, 1851] is about a big fish.

                They can also be applied to a phrase, rather then floating in the text. 

                ```(sam) 
                    {Moby Dick}[Melville, 1851] is about a big fish.

                Citations can be chained with annotations:

                ```(sam) 
                    {Moby Dick}(novel)[Melville, 1851] is about a big fish.

                Citations can also be added to {blockquotes}:

                ```(sam)
                    """[Melville, 1851] 
                        Call me Ishmael.

                SAM has no opinion about the citation format used in documents. That is entirely up to the application layer to decipher. 

                YOu can also use citations to reference other parts of the current document or other documents. To cite a resource that has an id within the current SAM document, reference the id like this: 

                ```(sam) 
                    Moby Dick is about a big fish[*moby]. See [*whale].

                    fig:(*whale)
                        >>>(image whale.png)

                    footnote:(*moby)
                        Actually, Moby Dick is a whale, not a fish.

            semantics:

                The function of a citation is to generate a piece of content in the output that is a reference to the specified resource. Some text should always be generated in the place where the citation is specified. What type of reference that is depends of the type of object that is being referenced. Generating such references is the job of the {application layer}.

                The purpose of a citation is not to create a link. Links should be created using {annotation}s. However, the reference generated by a citation may include a link to the resource in question if appropriate. 

                The semantics of a reference by {id}, {name}, or {key}, depend on the type of the structure referred to. Thus if the type of a object referred to by an {id}. This will usually be a reference to a type that is created in the specific tagging language being used, rather than to a SAM concrete block, so the semantics are up to the language designer. For example, if your tagging language includes footnotes, as in the last example above then the presumptive semantics of a {citation} of the footnote ID would be to product a footnote marker in the output. 

                The semantics of a citation of an external work is that it will generate a reference to that work in whatever citation format is appropriate for publication. This means that a citation that is inline in the SAM document necessarily implies that an inline citation format will be used on output. The SAM citation is just capturing the citation information. It is up to the application layer to decide how to present it, including removing the citation to a footnote or endnote if appropriate. The language designer is entitled to specify any citation format they like, and to interpret it in any way they like. 

            serialization:

                A {citation} is output as a `<citation>` element in XML. 

                The type of the citation is indicated by a `type` attribute. The supported types are:

                |citation| A textual citation. 
                |id| A SAM ID.
                |name| A SAM name.
                |key| A SAM key.

                The value of the citation is indicated by the `value` attribute.

                For example, 

                ```(xml) 
                    <p>Moby Dick<citation type="citation" value="Melville, 1851"> is about a big fish.

                If the citation is attached to a phrase, then the citation will be wrapped around the text of the phrase and nested inside the `<phrase>` element:

                ```(xml) 
                    <p><phrase><citation type="citation" value="Melville, 1851"/>Moby Dick</phrase> is about a big fish.

                If a citation and an annotation are attached to the same phrase, then the citation will be nested within the `<phrase>` element and relative to any `<annotation>` elements, just as with {annotation} nesting.

                ```(xml) 
                    <phrase><annotation type="novel"><citation type="citation" value="Melville, 1851">Moby Dick</citation></annotation></phrase> is about a big fish.


                If the citation is attached to a {blockquote}, the citation element will be nested inside the `<blockquote>` element.

                ```(sam)
                    <blockquote>
                        <citation type="citation" value="Melville, 1851"/> 
                        <p>Call me Ishmael.</p>
                    </blockquote>

        structure: String

            You can define a string:

            ```(sam)
                $foo = bar

            The string can then be inserted using a block or inline insert:

            ```(sam)
                >($foo)
                >>>($foo)

            String handling occurs in the application layer.

            String definitions do not take any attributes. The string name is a name. String ids are not supported. If
            you want to make string definitions conditional, use fragments.

            ```(sam)
                ~~~(?foo)
                    $foo = bar

        structure: Fragments 

            Fragments are created by a token followed by an open curly brace at the start of a line: 

            ```(sam) 
                ~~~(#my-fragment ?bar) 
                    $color=black 
                    Bar bar >>($color) sheep Have you any wool? 


            The content of the fragment must be indented, and the closing brace must be at the same indentation level as the opening one. 

            section: Insert a fragment 

                To insert a fragment: 

                ```(sam) 
                    >>>(~my-fragment)

                
                Any strings defined within a fragment are scoped to that fragment. You can override these strings when you insert the fragment. In fact, you can override any in-scope strings in a fragment insert. String definitions must each be on a line by themselves. 

                ```(sam)
                    >>>(~my-fragment)
                        $color=white

                Note that the SAM syntax is designed to bear these semantics, but that the SAM parser does not implement them. It simply passes them on to whatever processor you are using, which is free to implement different rules for string handling. 

            section: Shortcuts for inserts

                ```(sam)
                    # string
                    >>>($this.string)
                    >>>(string this.string)

                    # reference >(#this.ref) >(ref this.ref)

        structure: Codeblocks

            Codeblocks begin with three back ticks followed by an optional {annotation} and or {citation}.

            ```(sam)
                ```(sam)
                    This is a codeblock example.

                    This is more text in the codeblock.

            The text of the codeblock is not processed as SAM markup. It is recorded as is with
            no interpretation or escape processing.

            Code must be indented under the codeblock marker. The codeblock ends at the first line that is less indented than the codeblock, or at the end of the file.

            section: codeblock annotations
                Codeblock annotations are different from block annotations. They take the form:

                ```
                    ```(language)

                You can add the attributes {id}, {name}, and {condition} to a codeblock:

                ```(sam)
                    ```(python)(?lang=python)

        structure: Embedded markup
            You can embed markup in other markup languages. Unlike a codeblock, the intended semantics of
            an embed are that the markup will be processed in the application layer. For example, a piece
            of latex math markup might be processed in the application layer to display an equation.

            Note that SAM knows nothing about the embedded markup and does not processes it in any way.
            It merely captures it and sends it on to the application layer.

            An embed works just like a codeblock, except with three equals instead of three backticks.

            ```(sam)
                ===(latexmathml)(*id13)(#name)(?a)(?b)
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

        structure: Blockquotes 

            Three quotation marks in a row are a shortcut for the {implicit structure} "blockquote".

            ```(sam) 
                """[citation]
                    Quoted


            You can achieve the same effect by using the literal name blockquote (which is then just like any other block element):

            ```(sam) 
                blockquote:
                    citation:
                    Quoted


            section: Alternate blockquotes

                ```(sam) 
                    '''[citation]
                        Quoted

                
                The difference between code {```}(code) and quote `"""` is that code signals a different encoding. The content of the code block is not processed as SAM markup.

                In a blockquote, however, the material inside the quote block is still SAM markup and is processed as such.

        structure: Lines 
        
            Lines are pieces of text with fixed line endings, such as poems. To create a set of lines, precede each one with a pipe character followed by a space. 

            ```(sam) 
                | You gotta walk that lonesome valley,
                | You gotta walk it by yourself,
                | Nobody here can walk it for you,
                | You gotta walk it by yourself.


            You can also add ids or conditions to lines. In this case, the opening parentheses of the annotation must follow the leading pipe character immediately, and the closing parenthesis must be followed by a space: 

            ```(sam) 
                |(#foo) You gotta walk that lonesome valley,
                | You gotta walk it by yourself,
                |(?bar) Nobody here can walk it for you,
                | You gotta walk it by yourself.

            The entire line must be on one line in the source.

            All spaces after the first space following the pipe are considered significant and are retained on output.

        structure: Lists 

            You can create any kind of list you like by using nested blocks. 

            ```(SAM) 
                ul: 
                    li: Dog 
                    li: Hen 
                    li: Spoon 



            Shortcuts for ordered and unordered lists are supported. 

            Unordered lists begin with a line starting with an asterisk. 

            ```(SAM)
                * Dog
                * Hen
                * Spoon


            Ordered lists begin with a number followed by a period. 

            ```(SAM) 
                0. Robot
                12. Spaceship
                7. Ray gun


            The numbers are not retained, nor is their style. The processing application
            will decide the style and numbering of lists.

            Labeled lists begin with a label between pipe characters. There must be no space
            between the opening pipe character and the start of the label text. (Otherwise
            it will be parsed as a line, not a labeled list.

            ```(SAM) 
                |fa| A long long way to run.
                |so| A needle pulling thread.
                |la| A note to follow so.


            Lists continue until: 

            * The next non-blank line at the same indent that does not start with a list marker. 
            * The next non-blank line that is less indented. 
            * The end of the file. 

            List items continue until: 

            * The next para at the same indent that starts with a list marker. 
            * The end of the list.

        structure: Grids

            Grids are an very simple table-like construct. They are not full tables which are complex {document domain} beasts with potentially elaborate syntax. There are many ways to do {tables} or semantically represent data that may be displayed in tables in SAM. Grids are meant for the simplest cases that have no document domain or subject domain semantics. They are just a tick tack toe board.

            A grid is created by starting a line with three `+` signs. These may be followed by {block annotations}.

            Each row of the grid is on a separate line. Cells are separated by pipes. There is no pipe before the first cell or after the last. All rows must have the same number of cells.

            There is no concept of a header, no row or column spanning. A grid consists of rows and cells. Each cell contains a single {flow}. Each row must be on one line of the source files. Cell contents are trimmed of leading and trailing whitespace. This allows you to align the pipes if you wish (though this is not required).

            ```(SAM)
                +++
                    *Type*  | *Term*    | *Notes*

                    feature | fragment  | bing

                    feature | fragments | bang


            Management attributes are permitted on the grid, but not the rows.

            ```(SAM)
                +++(*foo #bar ?baz)
                    *Type*  | *Term*    | *Notes*

                    feature | fragment  | bing

                    feature | fragments | bang


        structure:(#comment) Comment

            A comment is a extra-textual comment on the markup of the document
            similar to a comment in code or in XML. 


            syntax:

                A comment is created by starting a line with a `#`. There 
                is no support for multi-line comments or for comments within
                running text. 

                ```(sam)
                    # This is a comment.

            XML:

                A comment is represented in XML as an XML comment.

                ```(xml)
                    <!-- This is a comment -->

        structure:(#remark) Remark

            A remark is an editorial comment on the document text. It may be displayed in a draft form or the document or while reviewing and revising the document. Remarks are similar to the comment features found in PDF files or WordProcessors.

            A remark is distinguished from a comment by the requirement that the author of the remark be identified in the remark.

            syntax:
                A remark looks like a {comment} with an annotation identifying the author:

                ```(sam)
                    #(Mark Baker) This is a remark.

                There must be no space between the `#` and the `(`.

            xml:
                The XML representation of a {remark} is as follows:

                ```(xml)
                    <remark author="Mark Baker">This is a remark.</remark>




        section: Whitespace handling

            All flows are trimmed of leading and trailing whitespace. In composing a flow from multiple text lines, all spaces and returns are collapsed to a single space.

        section: Decorations

            A decoration is a shortcut for creating an annotated phrase. For example,

            ```(sam)
                This text is in *important* type.

            is a shortcut for

            ```(sam)
                This text is {important}(bold).

            Annotation chaining is not supported for decorations.

            ```(sam)
                This text is *important*(italic).

            is not the same as

            ```(sam)
                This text is {important}(bold)(italic).

            Decorations cannot be nested, so

             ```(sam)
                This text is *_important_*.

            is not a shortcut for

            ```(sam)
                This text is {important}(bold)(italic)

            but would be interpreted as

            ```(sam)
                This text is {_important_}(bold).

            Decorations are not recognized inside of phrases, but are read as plain text.


        
        section: Embedded XML
        
            The embedded XML must begin with an XML declaration on a line by itself (typically `<?xml version="1.0" encoding="UTF-8"?>`). The XML fragment that follows must be well formed and must end on a line by itself. The SAM parser parses the embedded XML block to determine if it is well formed and to find its end. It then outputs the original XML from the SAM document, not the parser output. Therefore there will be no resolution of entities on the embedded XML. 

             ```
                test
                
        feature:(#name-token) Name tokens
        
            A name token is a string that represents the name of a {structure} in a SAM document. It follows the same rules as a XML local name. (This means it cannot contain a colon or a namespace prefix. Namespace prefixes are not used in SAM. {Namespaces are assigned to elements in the schema.}(future)  
            
        section: Conditions 

            Conditions are indicated using the {condition attribute}.

            SAM itself does not execute conditions, it merely encodes them for later processing. Therefore it has no idea what the tokens mean or how they will be interpreted. However, using simple tokens is recommended as a best practice. 


        section: Names and IDs 
        
            Blocks can be assigned names and IDs. Both are used to reference the block from elsewhere in the content. The difference is that ids are local to the current document and must be unique within the current document. If a duplicate ID is found, the parser will raise an error. 

            Names are merely assigned to the block by the parser. No namespace or uniqueness constraints are enforced. It is up to the application to decide how names are used. However, it is considered a SPFE idiom that names are scoped to the type of objects they apply to. In other words, fragment names are in a different namespace from string names.

            This implies that string references are distinct from fragment references.


        section:(#annotation-lookup) Annotation lookup

            If you are annotating the same phrase more than one in the same file. You can skip the annotation metadata and just use square brackets around the phrase. The parser will copy the metadata from the last occurring instance of that same phrase.

            ```(sam) 
                {foo}(bar "baz") gruznatz {foo}


        appendix: Annotation and attribute rules

            This is the list of the annotations and attributes allowed on each structure:

            +++
                block             | !language | #name | ?condition| *id |             |
                field             | !language | #name | ?condition| *id |             |
                fragment          | !language | #name | ?condition| *id |             |
                grid              | !language | #name | ?condition| *id |             |
                recordset         | !language | #name | ?condition| *id |             |
                ordered-list-ite  | !language | #name | ?condition| *id |             |
                unorderd-list-item| !language | #name | ?condition| *id |             |
                line              | !language | #name | ?condition| *id |             |

                blockquote        | !language | #name | ?condition| *id | \[citation] |
                phrase            | !language | #name | ?condition| *id | \[citation] | (annotation)

                codeblock         | encoding  | #name | ?condition| *id |             |
                embed             | encoding  | #name | ?condition| *id |             |

                string-def        |           |       |           |     |             |

                paragraph         |           |       |           |     |             |
                record            |           |       |           |     |             |
                XML               |           |       |           |     |             |

                block insert      |           | #name | ?condition| *id | type        | item
                inline insert     |           | #name | ?condition| *id | type        | item
                include           | href      |       |           |     |             |


