#!annotation-lookup: fancy

# This file is part of the SPFE Open Toolkit. See the accompanying license.txt file
# for applicable licenses.
# (c) Copyright Analecta Communications Inc. 2015 All Rights Reserved.

# Need test for unicode characters and numbers in names.

tests:(!en) SAM Parser Tests

    description:

        This document is the output of the test document processed by test.xslt.
        That stylesheet attempt to validate the outcome of tests by generating a string
        version of the markup under the `markup:`(sam) heading and comparing it to the
        text of the expected result as shown under the `result:` heading in the
        test file. This is not a perfect test. Two issues are known:

        1. Test are done on whitespace normalized versions of the XML markup
           strings. As such, they do not validly test situations where whitespace
           should be retained, such as in codeblocks and at the beginning of
           lines.

        2. The SAM parser outputs attributes in alphabetical order. (From an XML point of view,
           the order of attributes does not matter.) Test should be written such
           that the attributes in the `result:` section are in alphabetical
           order. If not, the test will fail even though the XML is semantically
           identical.

        When running this test you should receive one SAM Parser Warning:

        ```(terminal)
            SAM parser warning: Unannotated phrase found: {should be reported} If you are trying to insert curly braces into the document, use \{should be reported}.

        This is a test to make sure unannotated phrases are being reported correctly.

    test: Includes

        description:
            Include content from another SAM file.

        case: Local only annotations

            description:
                A local-only annotation is one which applies only to the current phrase.
                It is not taken into consideration in annotation lookup, so the lookup
                search will proceed to the next phrase with the same text. Annotation lookup will
                occur for a phrase with a local-only annotation, and the local annotation will
                be added to the looked up annotations, if any.

            source:
                ```(sam)
                    Testing {XML}(language) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}(language) testing {XML}+(index) testing {XML}.

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="language">XML</annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Simple include
            description:
                An include statement.

            source:
                ```(sam)
                    <<<(includeme.sam)

            markup:
                <<<(includeme.sam)

            result:
                ```(xml)
                    <message>
                    <title>Hello World.</title>
                    <p>This is the include test file.</p>
                    <grid>
                    <row>
                    <cell>foo</cell>
                    <cell>bar</cell>
                    </row>
                    <row>
                    <cell>baz</cell>
                    <cell>bat</cell>
                    </row>
                    </grid>
                    <p>Annotation lookup test: <phrase><annotation type="test">test phrase</annotation></phrase>.</p>
                    </message>

        case: Nested includes
            description:
                Including a file that itself includes a file.

            source:
                ```(sam)
                    <<<(includeme1.sam)

            markup:
                <<<(includeme1.sam)

            result:
                ```(xml)
                    <message>
                    <p>This file includes another file.</p>
                    <p>Nested includes work! Yipee!</p>
                    </message>

    test: Blocks

        description:
            Blocks are the basic building block of a SAM file. This whole document is a
            test case for blocks.
        case: Language metadata

            description:
                A block with language metadata.

            source:
                ```(sam)
                    section:(!sp)
                        Feliz Navidad

            markup:
                section:(!sp)
                    Feliz Navidad

            result:
                ```(xml)
                    <section xml:lang="sp">
                        <p>Feliz Navidad</p>
                    </section>

        case: Citations

            description:
                A citation on the block.

            source:
                ```(sam)
                    section:(!sp)[Mother McCree] Greeting
                        Feliz Navidad

            markup:
                section:(!sp)[Mother McCree] Greeting
                    Feliz Navidad

            result:
                ```(xml)
                    <section xml:lang="sp">
                        <citation value="Mother McCree"/>
                        <title>Greeting</title>
                        <p>Feliz Navidad</p>
                    </section>

        case: Escaping block syntax

            description:
                Escape colon to prevent single word followed by colon being recognized as a block.

            source:
                ```(sam)
                    and\:
            markup:
                and\:

            result:
                ```(xml)
                    <p>and:</p>



        case: Complex block structure

            description:
                A complex block with various structures inside.

            source:
                ```(sam)
                    document:
                        head:(#foo)
                            foo: barney {and}(conjunction) betty
                            baz: bat
                            $name=fred {and}(conjunction) wilma
                            history:: date, author, comment, status
                                2014-06-23, mbaker, New\, Topic, In progress
                                2016-07-01, mbaker, Revision, In progress
                            index:: type, term
                                feature, fragment
                                feature, fragments
                        body: How Fragments Work
                            Stuff on how fragments work.

            markup:
                document:
                    head:(#foo)
                        foo: barney {and}(conjunction) betty
                        baz: bat
                        $name=fred {and}(conjunction) wilma
                        history:: date, author, comment, status
                            2014-06-23, mbaker, New\, Topic, In progress
                            2016-07-01, mbaker, Revision, In progress
                        index:: type, term
                            feature, fragment
                            feature, fragments
                    body: How Fragments Work
                        Stuff on how fragments work.

            result:
                ```(xml)
                    <document>
                    <head name="foo">
                    <foo>barney <phrase><annotation type="conjunction">and</annotation></phrase> betty</foo>
                    <baz>bat</baz>
                    <string name="name">fred <phrase><annotation type="conjunction">and</annotation></phrase> wilma</string>
                    <history>
                    <record>
                    <date>2014-06-23</date>
                    <author>mbaker</author>
                    <comment>New, Topic</comment>
                    <status>In progress</status>
                    </record>
                    <record>
                    <date>2016-07-01</date>
                    <author>mbaker</author>
                    <comment>Revision</comment>
                    <status>In progress</status>
                    </record>
                    </history>
                    <index>
                    <record>
                    <type>feature</type>
                    <term>fragment</term>
                    </record>
                    <record>
                    <type>feature</type>
                    <term>fragments</term>
                    </record>
                    </index>
                    </head>
                    <body>
                    <title>How Fragments Work</title>
                    <p>Stuff on how fragments work.</p>
                    </body>
                    </document>

        case: Paragraph with colon in first word

            description:
                Case related to issue #94.

            source:
                ```(sam)
                    article: Foo

                        foo{bar}(http://www.example.com/).

                        `foo::bar` baz.

            markup:
                article: Foo

                    foo{bar}(http://www.example.com/).

                    `foo::bar` baz.

            result:
                ```(xml)
                    <article>
                    <title>Foo</title>
                    <p>foo<phrase><annotation type="link" specifically="http://www.example.com/">bar</annotation></phrase>.</p>
                    <p><code>foo::bar</code> baz.</p>
                    </article>

    # FIXME: Need tests for comments.

    test: Remarks
        description:
            Remarks are a type of comment that is attributed to an author and is used for
            commenting editorially on the document.

        case: Simple remark

            description:
                Just a simple remark. Nothing fancy.

            source:
                ```(sam)
                    !!!(mbaker)
                        This is a remark.

            markup:
                !!!(mbaker)
                    This is a remark.

            result:
                ```(xml)
                    <remark attribution="mbaker">
                    <p>This is a remark.</p>
                    </remark>

        case: Complex remark

            description:
                A little bit more complex.

            source:
                ```(sam)
                    !!!(Charles André Joseph Marie de Gaulle !@#$%^&*(((({}":<>)(*cdg1)(!fr)
                        This is a remark.

            markup:
                !!!(Charles André Joseph Marie de Gaulle !@#$%^&*(((({}":<>)(*cdg1)(!fr)
                    This is a remark.

            result:
                ```(xml)
                    <remark attribution="Charles André Joseph Marie de Gaulle !@#$%^&amp;*(((({}&quot;:&lt;&gt;" id="cdg1" xml:lang="fr">
                    <p>This is a remark.</p>
                    </remark>

    test: Fields
        description:
            A field is a block without children. A field value does not
            get wrapped in a title element. It is simple the value of the
            field.

        case: Nested fields
            description:
                Nested fields. Anything with a child, of course, is a block, not a field.

            source:
                ```(sam)
                    address:
                        name: Fred Flintstone
                        address: Bedrock
                        era: Stone Age

            markup:
                address:
                    name: Fred Flintstone
                    address: Bedrock
                    era: Stone Age

            result:
                ```(xml)
                    <address>
                    <name>Fred Flintstone</name>
                    <address>Bedrock</address>
                    <era>Stone Age</era>
                    </address>

    test: Paragraphs

        description:
            A paragraph is a block of text over consecutive lines.

        case: Paragraph
            description:
                A simple multi-line paragraph ending with a blank space.

            source:
                ```(sam)
                    Wafting zephyrs
                    quickly vexed
                    Jumbo.

            markup:
                Wafting zephyrs
                quickly vexed
                Jumbo.

            result:
                ```(xml)
                    <p>Wafting zephyrs quickly vexed Jumbo.</p>

        case: With annotated phrase

            description:
                A paragraph over multiple lines with an annotated phrase.

            source:
                ```(sam)
                    This is a {paragraph}(foo)
                    that wraps across
                    multiple lines.

            markup:
                This is a {paragraph}(foo)
                that wraps across
                multiple lines.

            result:
                ```(xml)
                    <p>This is a <phrase><annotation type="foo">paragraph</annotation></phrase> that wraps across multiple lines.</p>

    test: Ordered lists

        description:
            Ordered lists are created by starting a line with a number followed by a period.
            Exact numbers are not retained.

        case: Ordered list with spaces

            description:
                Ordered lists can have blank lines between the items.


            source:
                ```(sam)

                    0. One

                    0. Two

                    99999. Three

            markup:

                0. One

                0. Two

                99999. Three

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>


        case: Ordered list no spaces

            description:
                List are also recognized without space between items. List items can wrap
                to another line if more indented than the number. Additional paragraphs can be
                included if more indented than the number.

            source:
                ```(sam)

                    0. One
                    0. Two this
                       paragraph wraps.

                       This is another para in the list item.
                    99999. Three

            markup:
                0. One
                0. Two this
                   paragraph wraps.

                   This is another para in the list item.
                99999. Three

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two this paragraph wraps.</p>
                    <p>This is another para in the list item.</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>

        case: Ordered list mixed spacing

            description:
                Ordered list with inconsistent spacing.

            source:
                ```(sam)
                    0. One

                    0. Two
                    99999. Three

                    7. Four

            markup:
                0. One

                0. Two
                99999. Three

                7. Four

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested ordered list with spaces

            description:
                Ordered lists at different indents, with spaces between lines.

            source:
                ```(sam)
                    0. One

                    0. Two x

                        5. Two and a quarter x

                        6. Two and a half

                        9. Two and three quarters

                    99999. Three

                    7. Four

            markup:
                0. One

                0. Two x

                    5. Two and a quarter x

                    6. Two and a half

                    9. Two and three quarters

                99999. Three

                7. Four

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two x</p>
                    <ol>
                    <li>
                    <p>Two and a quarter x</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ol>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>



        case: Nested ordered lists with no spaces

            description:
                Ordered lists at different indents, with no spaces between lines.

            source:
                ```(sam)
                    0. One
                    0. Two z
                        5. Two and a quarter z
                        6. Two and a half
                        9. Two and three quarters
                    99999. Three
                    7. Four

            markup:
                0. One
                0. Two z
                    5. Two and a quarter z
                    6. Two and a half
                    9. Two and three quarters
                99999. Three
                7. Four

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two z</p>
                    <ol>
                    <li>
                    <p>Two and a quarter z</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ol>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested ordered list with mixed spacing

            description:
                Ordered lists at different indents, with some spaces between lines.

            source:
                ```(sam)
                    0. One
                    0. Two r
                        5. Two and a quarter r

                        6. Two and a half
                        9. Two and three quarters

                    99999. Three

                    7. Four

            markup:
                0. One
                0. Two r
                    5. Two and a quarter r

                    6. Two and a half
                    9. Two and three quarters

                99999. Three

                7. Four

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two r</p>
                    <ol>
                    <li>
                    <p>Two and a quarter r</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ol>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

    test: Unordered lists

        description:
            Unordered lists are indicated by starting a line with `*`.

        case: Unordered list with spaces

            description:
                A list with spaces between the lines.

            source:
                ```(sam)

                    * One

                    * Two t

                    * Three

            markup:

                * One

                * Two t

                * Three

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two t</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>

        case: Unordered list no spaces

            description:
                A list with no spaces between the lines.

            source:
                ```(sam)

                    * One
                    * Two y
                    * Three

            markup:

                * One
                * Two y
                * Three

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two y</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>

        case: Unordered list mixed spacing

            description:
                A list with mixed spacing between the lines.

            source:
                ```(sam)

                    * One
                    * Two u

                    * Three
                    * Four

            markup:

                * One
                * Two u

                * Three
                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two u</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>


        case: Nested list with spaces

            description:
                Nested lists separated by spaces.

            source:
                ```(sam)


                    * One

                    * Two i

                        * Two and a quarter

                        * Two and a half

                        * Two and three quarters

                    * Three

                    * Four

            markup:
                * One

                * Two i

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters

                * Three

                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two i</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>



        case: Nested unordered list with no spaces
            description:
                Nested lists not separated by spaces.

            source:
                ```(sam)
                    * One
                    * Two k
                        * Two and a quarter
                        * Two and a half
                        * Two and three quarters
                    * Three
                    * Four

            markup:
                * One
                * Two k
                    * Two and a quarter
                    * Two and a half
                    * Two and three quarters
                * Three
                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two k</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>

        case: Nested unordered list with mixed spacing

            description:
                Nested lists separated by some spaces.

            source:
                ```(sam)
                    * One
                    * Two p
                        * Two and a quarter p

                        * Two and a half
                        * Two and three quarters

                    * Three
                    * Four

            markup:
                * One
                * Two p
                    * Two and a quarter p

                    * Two and a half
                    * Two and three quarters

                * Three
                * Four

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two p</p>
                    <ul>
                    <li>
                    <p>Two and a quarter p</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ul>

    test: Mixed lists

        description:

            You can nest ordered and unordered lists inside each other or follow
            a list of one type with a list of another type.

        case: Nested mixed lists with spaces

            description:

                Unordered inside ordered list, spaces between lines.

            source:
                ```(sam)
                    0. One

                    0. Two a

                        * Two and a quarter

                        * Two and a half

                        * Two and three quarters

                    99999. Three

                    7. Four

            markup:
                0. One

                0. Two a

                    * Two and a quarter

                    * Two and a half

                    * Two and three quarters

                99999. Three

                7. Four

            result:

                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two a</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>


        case: Nested mixed lists with no spaces

            description:

                Unordered inside ordered list, no spaces between lines.

            source:
                ```(sam)
                    0. One
                    0. Two s
                        * Two and a quarter
                        * Two and a half
                        * Two and three quarters
                    99999. Three
                    7. Four

            markup:
                0. One
                0. Two s
                    * Two and a quarter
                    * Two and a half
                    * Two and three quarters
                99999. Three
                7. Four

            result:

                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two s</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>

        case: Nested numbered lists with mixed spacing

            description:

                Unordered inside ordered list, some spaces between lines.

            source:
                ```(sam)
                    0. One

                    0. Two d
                        * Two and a quarter

                        * Two and a half
                        * Two and three quarters
                    99999. Three times
                           three is nine.

                           Four times four is sixteen.

                           Five time five is twenty five.


                    7. Four

            markup:
                0. One

                0. Two d
                    * Two and a quarter

                    * Two and a half
                    * Two and three quarters
                99999. Three times
                       three is nine.

                       Four times four is sixteen.

                       Five time five is twenty five.

                7. Four

            result:

                ```(xml)
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two d</p>
                    <ul>
                    <li>
                    <p>Two and a quarter</p>
                    </li>
                    <li>
                    <p>Two and a half</p>
                    </li>
                    <li>
                    <p>Two and three quarters</p>
                    </li>
                    </ul>
                    </li>
                    <li>
                    <p>Three times three is nine.</p>
                    <p>Four times four is sixteen.</p>
                    <p>Five time five is twenty five.</p>
                    </li>
                    <li>
                    <p>Four</p>
                    </li>
                    </ol>



        case: Space between lists
            description:
                An ordered list can follow an unordered list directly and vice versa.


            source:
                ```(sam)
                    * One
                    * Two f
                    * Three

                    1. One
                    2. Two g
                    3. Three

            markup:
                * One
                * Two f
                * Three

                1. One
                2. Two g
                3. Three

            result:
                ```(xml)

                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two f</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two g</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>


        case: No space between lists

            description:
                An unordered list followed by an ordered list with no space between them.

            source:
                ```(sam)
                    * One
                    * Two h
                    * Three
                    1. One
                    2. Two j
                    3. Three

            markup:
                * One
                * Two h
                * Three
                1. One
                2. Two j
                3. Three

            result:
                ```(xml)

                    <ul>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two h</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ul>
                    <ol>
                    <li>
                    <p>One</p>
                    </li>
                    <li>
                    <p>Two j</p>
                    </li>
                    <li>
                    <p>Three</p>
                    </li>
                    </ol>

    test: Literal lists

        description:
            Ordered lists have the number stripped away and are renumbered on output.
            Unordered list have their `*` stripped away and replaced with the style of
            bullet specified on output processing. If you want to preserve actual
            numbers and bullets in your lists, you need to escape them so that the
            lines are not recognized as lists items.

        case: Literal numbered list using `\` to escape `.`

            description:
                To have a list number recognized as a literal, escape the period
                following the number (not the number itself). Because these are
                now paragraphs, not lists, you must put spaces between items or
                they will be run together into one paragraph.

            source:
                ```(sam)

                    2\. This is just a paragraph

                    4\. This is just a paragraph

                    9\. This is just a paragraph

            markup:
                2\. This is just a paragraph

                4\. This is just a paragraph

                9\. This is just a paragraph

            result:
                ```(xml)
                    <p>2. This is just a paragraph</p>
                    <p>4. This is just a paragraph</p>
                    <p>9. This is just a paragraph</p>


        case: Literal unordered list using `\` to escape `*`

            description:
                To have a list number recognized as a literal, escape the `*`. Because these are
                now paragraphs, not lists, you must put spaces between items or
                they will be run together into one paragraph.

            source:
                ```(sam)
                    \* This is just a paragraph

                    \* This is just a paragraph

                    \* This is just a paragraph

            markup:
                \* This is just a paragraph

                \* This is just a paragraph

                \* This is just a paragraph

            result:
                ```(xml)
                    <p>* This is just a paragraph</p>
                    <p>* This is just a paragraph</p>
                    <p>* This is just a paragraph</p>

    test: Labeled lists
        description:
            You can create lists with labels rather than bullets. The label is
            contained between two pipe characters. There must be no space between
            the opening pipe and the first character of the label (otherwise it
            will be parsed as a line).

        case: Simple labeled list

            description:
                A labeled list.

            source:
                ```(sam)
                    |Do| a deer,
                         a female deer
                    |Re| a drop of
                         golden sun

                         Is it a particle or a wave?
                    |Me| a name I call myself
                    |Fa| a long long way to run
                    |So| a needle pulling thread
                    |La| a note to follow so
                    |Te| a drink with jam and bread

            markup:
                |Do| a deer,
                     a female deer

                |Re| a drop of
                     golden sun

                     Is it a particle or a wave?
                |Me| a name I call myself
                |Fa| a long long way to run
                |So| a needle pulling thread
                |La| a note to follow so
                |Te| a drink with jam and bread

            result:
                ```(xml)
                    <ll>
                    <li>
                    <label>Do</label>
                    <p>a deer, a female deer</p>
                    </li>
                    <li>
                    <label>Re</label>
                    <p>a drop of golden sun</p>
                    <p>Is it a particle or a wave?</p>
                    </li>
                    <li>
                    <label>Me</label>
                    <p>a name I call myself</p>
                    </li>
                    <li>
                    <label>Fa</label>
                    <p>a long long way to run</p>
                    </li>
                    <li>
                    <label>So</label>
                    <p>a needle pulling thread</p>
                    </li>
                    <li>
                    <label>La</label>
                    <p>a note to follow so</p>
                    </li>
                    <li>
                    <label>Te</label>
                    <p>a drink with jam and bread</p>
                    </li>
                    </ll>

        case: XML markup characters in list labels

            description:
                Making sure that the contents of a list label are properly escaped when generating XML.

            source:
                ```(sam)
                  |foo1 & bar1| foobar1
                  |foo2 & bar2| foobar2
                  |foo3 & bar3| foobar3

            markup:
                |foo1 & bar1| foobar1
                |foo2 & bar2| foobar2
                |foo3 & bar3| foobar3

            result:
                ```(xml)
                    <ll>
                    <li>
                    <label>foo1 &amp; bar1</label>
                    <p>foobar1</p>
                    </li>
                    <li>
                    <label>foo2 &amp; bar2</label>
                    <p>foobar2</p>
                    </li>
                    <li>
                    <label>foo3 &amp; bar3</label>
                    <p>foobar3</p>
                    </li>
                    </ll>

    test: Record sets

        description:
            Record sets are a structure similar to a database table. They
            record data in rows with identical column names. Column names
            are specified in the records set header.

        case: Recordset

            description:
                Test that recordsets are recognized correctly. Includes a
                test that character escapes are recognized in records and
                commas can be escaped.

            source:
                ```(sam)
                    history:: date, author, comment, status
                        2014-06-23, mbaker, New\, Topic, In progress
                        2016-07-01, mbaker, Revision, In progress

            markup:
                history:: date, author, comment, status
                    2014-06-23, mbaker, New\, Topic, In progress
                    2016-07-01, mbaker, Revision, In progress

            result:
                ```(xml)
                    <history>
                    <record>
                    <date>2014-06-23</date>
                    <author>mbaker</author>
                    <comment>New, Topic</comment>
                    <status>In progress</status>
                    </record>
                    <record>
                    <date>2016-07-01</date>
                    <author>mbaker</author>
                    <comment>Revision</comment>
                    <status>In progress</status>
                    </record>
                    </history>

        case: Recordset with only one field name

            description:
                Test that a recordset works correctly with only one field.

            source:
                ```(sam)
                    filmography:: film
                        Rio Bravo
                        The Shootish

            markup:
                filmography:: film
                    Rio Bravo
                    The Shootish

            result:
                ```(xml)
                    <filmography>
                    <record>
                    <film>Rio Bravo</film>
                    </record>
                    <record>
                    <film>The Shootish</film>
                    </record>
                    </filmography>

    test: Grids

        description:

            Grids are a simple form of table. They are purely a layout device with
            no semantic value. They have no table heads or row or
            column spanning. More complex tables can be modeled using explicit
            blocks. Labeled lists can be modeled using the labeled list structure.
            Database-like tables can be modeled using record sets.

        case: Grid with heads

            description:

                Table heads are simulated using bold in the top row of the grid.

            source:
                ```(sam)
                    +++
                        *Type*  | *Term*    | *Notes*
                        feature | fragment  | bing
                        feature | fragments | bang

            markup:
                +++
                    *Type*  | *Term*    | *Notes*
                    feature | fragment  | bing
                    feature | fragments | bang

            result:
                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>

        case: Grid with management domain attributes

            description:
                The same grid only with management domain attributes attached
                to the grid header.

                Note that SAM Parser sorts block attributes alphabetically for
                output, which makes it possible to test them with a simple string
                comparison (such as that performed by test.xslt). However, this
                is behavior of this parser, not a SAM language requirement.

            source:
                ```(sam)
                    +++(*foom)(#bar)(?baz)
                        *Type*  | *Term*    | *Notes*

                        feature | fragment  | bing

                        feature | fragments | bang

            markup:
                +++(*foom)(#bar)(?baz)
                    *Type*  | *Term*    | *Notes*

                    feature | fragment  | bing

                    feature | fragments | bang

            result:
                ```(xml)
                    <grid conditions="baz" id="foom" name="bar">
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>


        case: Grid with bold row

            description:

                Make an lower row bold.

            source:
                ```(sam)
                    +++
                        *Type*    | *Term*      | *Notes*
                        feature   | fragment    | bing
                        *feature* | *fragments* | *bang*
            markup:
                +++
                    *Type*    | *Term*      | *Notes*
                    feature   | fragment    | bing
                    *feature* | *fragments* | *bang*

            result:
                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Term</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">Notes</annotation></phrase></cell>
                    </row>
                    <row>
                    <cell>feature</cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell><phrase><annotation type="bold">feature</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">fragments</annotation></phrase></cell>
                    <cell><phrase><annotation type="bold">bang</annotation></phrase></cell>
                    </row>
                    </grid>


        case: Grid with side heads

            description:

                Grid with row headings rather than column headings.

            source:
                ```(sam)
                    +++
                        *Type*    | Term      | Notes
                        *feature* | fragment  | bing
                        *feature* | fragments | bang
            markup:
                +++
                    *Type*    | Term      | Notes
                    *feature* | fragment  | bing
                    *feature* | fragments | bang

            result:
                ```(xml)
                    <grid>
                    <row>
                    <cell><phrase><annotation type="bold">Type</annotation></phrase></cell>
                    <cell>Term</cell>
                    <cell>Notes</cell>
                    </row>
                    <row>
                    <cell><phrase><annotation type="bold">feature</annotation></phrase></cell>
                    <cell>fragment</cell>
                    <cell>bing</cell>
                    </row>
                    <row>
                    <cell><phrase><annotation type="bold">feature</annotation></phrase></cell>
                    <cell>fragments</cell>
                    <cell>bang</cell>
                    </row>
                    </grid>

    test: Blockquotes
        description:
            Blockquotes are introduced by three quotations marke (single or double). The content of
            a blockquote is normal SAM markup.

        case: Blockquote
            description:
                A blockquote with management domain metadata.


            source:
                ```(sam)
                    After this paragraph, there is a blockquote:

                    """(*foo)(#bar)(?baz)
                        The quick brown fox jumps over the lazy dog.

                        And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.

            markup:
                After this paragraph, there is a blockquote:

                """(*foo)(#bar)(?baz)
                    The quick brown fox jumps over the lazy dog.

                    And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.

            result:
                ```(xml)
                    <p>After this paragraph, there is a blockquote:</p>
                    <blockquote conditions="baz" id="foo" name="bar">
                    <p>The quick brown fox jumps over the lazy dog.</p>
                    <p>And the <phrase><annotation type="beast" specifically="bovine"><citation value="Mother Goose">cow</citation></annotation></phrase> jumps over the moon.</p>
                    </blockquote>

        case: Alternate block quote
            description:
                Blockquote with single quotes. Includes multiple citations.

            source:
                ```(sam)
                    This is another paragraph. Then there is an alternate blockquote:

                    '''( #foo5)[Mother Goose](?bar)(?baz)[Father Time][*foo page 2]
                        The quick brown fox jumps over the lazy dog.

                    '''
                        This is a blockquote without a citation.

            markup:
                This is another paragraph. Then there is an alternate blockquote:

                '''( #foo5)[Mother Goose](?bar)(?baz)[Father Time][*foo page 2]
                    The quick brown fox jumps over the lazy dog.

                '''
                    This is a blockquote without a citation.


            result:
                ```(xml)
                    <p>This is another paragraph. Then there is an alternate blockquote:</p>
                    <blockquote conditions="bar,baz" name="foo5">
                    <citation value="Mother Goose"/>
                    <citation value="Father Time"/>
                    <citation extra="page 2" idref="foo"/>
                    <p>The quick brown fox jumps over the lazy dog.</p>
                    </blockquote>
                    <blockquote>
                    <p>This is a blockquote without a citation.</p>
                    </blockquote>

    test: Codeblocks
        description:
            A codeblock is a block of program code. A codeblock is treated as
            plain text and is not parsed as SAM markup. It will be copied to
            output exactly as it occurs in the source. Codeblocks are denoted
            by three back ticks at the start of a line. Codeblocks have a special
            annotation. The first word of an annotation on a codeblock is
            the language of the code.

        case: Simple codeblock

            description:
                A simple codeblock.

            source:
                ```(sam)
                    ```(pyt&#x68;on)(?foo)(!en)
                        def escape_for_xml(s):
                            t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                            try:
                                return s.translate(t)
                            except AttributeError:
                                return s
            markup:
                ```(pyt&#x68;on)(?foo)(!en)
                    def escape_for_xml(s):
                        t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s

            result:
                ```(xml)
                    <codeblock conditions="foo" language="python" xml:lang="en">
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

        case: Blank lines in codeblock

            description:
                Blank lines in a code block. The display of the result will be
                confusing here because the result is whitespace normalized for
                ease of comparison with the generated XML.

            source:
                ```(sam)
                    ```(sam)
                        warnings:
                            warning:(#warn_danger_domestic)
                                title: Danger

                                Be very very careful. This could kill you.

                            warning:(#warn_danger_foreign)
                                title: Look out!

                                Pay close attention. You could really hurt yourself.
            markup:
                ```(sam)
                    warnings:
                        warning:(#warn_danger_domestic)
                            title: Danger

                            Be very very careful. This could kill you.

                        warning:(#warn_danger_foreign)
                            title: Look out!

                            Pay close attention. You could really hurt yourself.
            result:
                ```(xml)
                    <codeblock language="sam">
                    warnings:
                        warning:(#warn_danger_domestic)
                            title: Danger

                            Be very very careful. This could kill you.

                        warning:(#warn_danger_foreign)
                            title: Look out!

                            Pay close attention. You could really hurt yourself.
                    </codeblock>

        case: Codeblock with citation

            description:
                A codeblock with a citation.

            source:
                ```(sam)
                    ```(python)(?foo)[demos/foo.py]
                        def escape_for_xml(s):
                            t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                            try:
                                return s.translate(t)
                            except AttributeError:
                                return s
            markup:
                ```(python)(?foo)[demos/foo.py]
                    def escape_for_xml(s):
                        t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s

            result:
                ```(xml)
                    <codeblock conditions="foo" language="python">
                    <citation value="demos/foo.py"/>
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

        case: Invalid blockstart in codeblock
            description:
                This is an construct that raise an error in an actual document. Curious because
                lots of valid block starts in other codeblocks did not cause a problem. But this
                one raised an invalid block name error. Turns out this was caused by tabs instead
                of spaces used to indent the line, which promoted it to a higher level of the
                document hierarchy and thus outside the codeblock. But the test is worth keeping
                to make sure that the contents of codeblocks are not being interpreted as SAM markup.

            source:
                ```(sam)
                    ```
                        first-ordered-list-item =
                            {fontx: 12pt "Century Schoolbook"}<count=1>.[tab]
                        ordered-list-item =
                            {fonty: 12pt "Century Schoolbook"}<++count>.[tab]

            markup:
                ```
                    first-ordered-list-item =
                        {fontx: 12pt "Century Schoolbook"}<count=1>.[tab]
                    ordered-list-item =
                        {fonty: 12pt "Century Schoolbook"}<++count>.[tab]

            result:
                ```(xml)
                    <codeblock>
                    first-ordered-list-item =
                        {fontx: 12pt "Century Schoolbook"}&lt;count=1&gt;.[tab]
                    ordered-list-item =
                        {fonty: 12pt "Century Schoolbook"}&lt;++count&gt;.[tab]
                    </codeblock>

    test: Embedblock
        description:
            An embed is a block of markup or code in another language that is intended to be interpreted rather than displayed. For instance, it can be used to include an equation using LaTeX or a diagram using SVG.

        case: Simple embed

            description:
                Simple embed of an equation using LaTeX.

            source:
                ```(sam)
                    ```(=latexmathml)(*id13)(#name)(?a)(?b)
                        n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            markup:
                ```(=latexmathml)(*id13)(#name)(?a)(?b)
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            result:
                ```(xml)
                    <embedblock conditions="a,b" encoding="latexmathml" id="id13" name="name"> n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k </embedblock>

        case: Embedded XML 

            description:
                A chunk of XML.

            source:
                ```(sam)
                    ```(=xml)
                        <?xml version="1.0" encoding="UTF-8"?>
                        <foo bar="bat">
                            <boo/>
                            <hoo/>
                        </foo>

            markup:
                ```(=xml)
                    <?xml version="1.0" encoding="UTF-8"?>
                    <foo bar="bat">
                        <boo/>
                        <hoo/>
                    </foo>

            result:
                ```(xml)
                    <embedblock encoding="xml">
                        &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
                        &lt;foo bar="bat"&gt; 
                        &lt;boo/&gt; 
                        &lt;hoo/&gt; 
                        &lt;/foo&gt;
                    </embedblock>
    test: Lines

        description:
            Lines allows you to create text with specific line breaks. Lines are created by
            beginning each line on a new line and starting with a `|` character. There must
            be one space after the `|`, which is discarded. All other spaces after `|` are
            retained. (Retained spaces are not tested for in text.xslt because the test
            normalize space.)

        case: Lines

            description:
                Lines with various annotations:

            source:
                ```(sam)
                    |(#foo2) You gotta walk that lonesome valley,[*bing page 22]
                    | You gotta walk it by yourself,
                    |(?bar) Nobody here can walk it for you,
                    |    You gotta walk it by yourself.
            markup:
                |(#foo2) You gotta walk that lonesome valley,[*bing page 22]
                | You gotta walk it by yourself,
                |(?bar) Nobody here can walk it for you,
                |    You gotta walk it by yourself.

            result:
                ```(xml)
                    <line name="foo2">You gotta walk that lonesome valley,<citation extra="page 22" idref="bing"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line conditions="bar">Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>

        case: Lines inside a blockquote

            description:
                Lines should work inside a block quote.

            source:
                ```(sam)
                    """[*bing page 22]
                        |(#foo2) You gotta walk that lonesome valley,[%bing page 22]
                        | You gotta walk it by yourself,
                        |(?bar) Nobody here can walk it for you,
                        |    You gotta walk it by yourself.

            markup:
                """[*bing page 22]
                    |(#foo2) You gotta walk that lonesome valley,[%bing page 22]
                    | You gotta walk it by yourself,
                    |(?bar) Nobody here can walk it for you,
                    |    You gotta walk it by yourself.

            result:
                ```(xml)
                    <blockquote>
                    <citation extra="page 22" idref="bing"/>
                    <line name="foo2">You gotta walk that lonesome valley,<citation extra="page 22" keyref="bing"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line conditions="bar">Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>
                    </blockquote>

    test: Attributes

        description:

            SAM supports four explicit attributes: ids, names, conditions, and language. There is no
            general attribute mechanism such as that in XML. You can generally encode the same data
            in SAM using fields or annotations.

            Attributes can
            be applied to blocks, phrases, and inserts. You cannot apply attributes to a paragraph,
            but you can wrap a paragraph in a fragment and apply attributes to the fragment.

            Attributes are applied using annotation markup, but with a specific initial character to
            denote each kind of attribute:

            * `(*id)` creates an ID attribute.
            * `(#name)` creates a name attribute.
            * `(?condition)` creates a condition attribute.
            * `(!en-CA)` creates a language attribute.

            You can only apply one id, name, or language attribute to a block or phrase. You can apply more
            than one condition attribute. On output to XML, the condition attributes will be converted to
            a single `conditions` attribute with the individual conditions separated by commas. (For which reason,
            condition statements can't include commas.)

        case: Attributes on block

            description: Attributes on a block


            source:
                ```(sam)
                    block:(!en-CA)(*id2)(#name)(?a)(?b) Title

                        Content of the block.

            markup:
                block:(!en-CA)(*id2)(#name)(?a)(?b) Title

                    Content of the block.

            result:
                ```(xml)
                    <block conditions="a,b" id="id2" name="name" xml:lang="en-CA">
                    <title>Title</title>
                    <p>Content of the block.</p>
                    </block>

        case: Attributes on field

            description: Attributes on a field


            source:
                ```(sam)
                    field:(!en-CA)(*id3)(#name)(?a)(?b) Value of the field.

            markup:
                field:(!en-CA)(*id3)(#name)(?a)(?b) Value of the field.

            result:
                ```(xml)
                    <field conditions="a,b" id="id3" name="name" xml:lang="en-CA">Value of the field.</field>

        case: Attributes on fragment

            description: Attributes on a fragment


            source:
                ```(sam)
                    ~~~(!en-CA)(*id4)(#name)(?a)(?b)

                        Content of the fragment.

            markup:
                ~~~(!en-CA)(*id4)(#name)(?a)(?b)

                        Content of the fragment.

            result:
                ```(xml)
                    <fragment conditions="a,b" id="id4" name="name" xml:lang="en-CA">
                    <p>Content of the fragment.</p>
                    </fragment>

        case: attributes on grid

            description: Attributes on a grid


            source:
                ```(sam)
                    +++(!en-CA)(*id5)(#name)(?a)(?b)

                        Content | of
                        the     | grid.

            markup:
                +++(!en-CA)(*id5)(#name)(?a)(?b)

                    Content | of
                    the     | grid.

            result:
                ```(xml)
                    <grid conditions="a,b" id="id5" name="name" xml:lang="en-CA">
                    <row>
                    <cell>Content</cell>
                    <cell>of</cell>
                    </row>
                    <row>
                    <cell>the</cell>
                    <cell>grid.</cell>
                    </row>
                    </grid>

        case: attributes on record set

            description: Attributes on a record set


            source:
                ```(sam)
                    recordset::(!en-CA)(*id6)(#name)(?a)(?b) foo, bar

                        a, b
                        c, d

            markup:
                recordset::(!en-CA)(*id6)(#name)(?a)(?b) foo, bar

                    a, b
                    c, d

            result:
                ```(xml)
                    <recordset conditions="a,b" id="id6" name="name" xml:lang="en-CA">
                    <record>
                    <foo>a</foo>
                    <bar>b</bar>
                    </record>
                    <record>
                    <foo>c</foo>
                    <bar>d</bar>
                    </record>
                    </recordset>


        case: Attributes on unordered list

            description:

                Attributes on an unordered list item.

            source:
                ```(sam)
                    * Fred

                    *(!en-CA)(*id7)(#name)(?a)(?b) Barney and
                                                   Betty and
                                                   Bam Bam.

                    * Wilma

            markup:

                * Fred

                *(!en-CA)(*id7)(#name)(?a)(?b) Barney and
                                               Betty and
                                               Bam Bam.

                * Wilma

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="a,b" id="id7" name="name" xml:lang="en-CA">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ul>

        case: Attributes on ordered list
            description:
                Attributes on an ordered list item.

            source:
                ```(sam)
                    1. Fred
                    2.(!en-CA)(*id8)(#name)(?a)(?b) Barney and
                                                    Betty and
                                                    Bam Bam.
                    3. Wilma

            markup:
                1. Fred
                2.(!en-CA)(*id8)(#name)(?a)(?b) Barney and
                                                Betty and
                                                Bam Bam.
                3. Wilma

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="a,b" id="id8" name="name" xml:lang="en-CA">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ol>

        case: Attributes on labeled list
            description:
                Attributes on a labeled list item.

            source:
                ```(sam)
                    |Do|(#foo)(?bar)(?green) a deer,
                                             a female deer

                    |Re| a drop of
                         golden sun

                         Is it a particle or a wave?
                    |Me|(*bananas) a name I call myself
                    |Fa| a long long way to run
                    |So| a needle pulling thread
                    |La| a note to follow so
                    |Te| a drink with jam and bread

            markup:
                |Do|(#foo)(?bar)(?green) a deer,
                                         a female deer

                |Re| a drop of
                     golden sun

                     Is it a particle or a wave?
                |Me|(*bananas) a name I call myself
                |Fa| a long long way to run
                |So| a needle pulling thread
                |La| a note to follow so
                |Te| a drink with jam and bread

            result:
                ```(xml)
                    <ll>
                    <li conditions="bar,green" name="foo">
                    <label>Do</label>
                    <p>a deer, a female deer</p>
                    </li>
                    <li>
                    <label>Re</label>
                    <p>a drop of golden sun</p>
                    <p>Is it a particle or a wave?</p>
                    </li>
                    <li id="bananas">
                    <label>Me</label>
                    <p>a name I call myself</p>
                    </li>
                    <li>
                    <label>Fa</label>
                    <p>a long long way to run</p>
                    </li>
                    <li>
                    <label>So</label>
                    <p>a needle pulling thread</p>
                    </li>
                    <li>
                    <label>La</label>
                    <p>a note to follow so</p>
                    </li>
                    <li>
                    <label>Te</label>
                    <p>a drink with jam and bread</p>
                    </li>
                    </ll>

        case: Attributes on lines

            description:
                Lines with annotations:

            source:
                ```(sam)
                    |(!en-CA)(*id9)(#name)(?a)(?b) You gotta walk that lonesome valley,[*bing page 22]
                    | You gotta walk it by yourself,
                    | Nobody here can walk it for you,
                    |    You gotta walk it by yourself.
            markup:
                |(!en-CA)(*id9)(#name)(?a)(?b) You gotta walk that lonesome valley,[*bing page 22]
                | You gotta walk it by yourself,
                | Nobody here can walk it for you,
                |    You gotta walk it by yourself.

            result:
                ```(xml)
                    <line conditions="a,b" id="id9" name="name" xml:lang="en-CA">You gotta walk that lonesome valley,<citation extra="page 22" idref="bing"/></line>
                    <line>You gotta walk it by yourself,</line>
                    <line>Nobody here can walk it for you,</line>
                    <line>   You gotta walk it by yourself.</line>


        case: Attributes on blockquote
            description:
                A blockquote with attributes and a citation.


            source:
                ```(sam)
                    After this paragraph, there is a blockquote:

                    """(!en-CA)(*id10)(#name)(?a)(?b)[*cit]
                        The quick brown fox jumps over the lazy dog.

                        And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.

            markup:
                After this paragraph, there is a blockquote:

                """(!en-CA)(*id10)(#name)(?a)(?b)[*cit]
                    The quick brown fox jumps over the lazy dog.

                    And the {cow}(beast "bovine")[Mother Goose] jumps over the moon.

            result:
                ```(xml)
                    <p>After this paragraph, there is a blockquote:</p>
                    <blockquote conditions="a,b" id="id10" name="name" xml:lang="en-CA">
                    <citation idref="cit"/>
                    <p>The quick brown fox jumps over the lazy dog.</p>

                    <p>And the <phrase><annotation type="beast" specifically="bovine"><citation value="Mother Goose">cow</citation></annotation></phrase> jumps over the moon.</p>
                    </blockquote>


        case: Attributes on a phrase

            description:
                Attributes on a phrase.

            source:
                ```(sam)
                    {The Duke}(actor "John Wayne")(!en-CA)(*id11)(#name)(?a)(?b)[*cit] plays Rooster Cogburn.

            markup:
                {The Duke}(actor "John Wayne")(!en-CA)(*id11)(#name)(?a)(?b)[*cit] plays Rooster Cogburn.

            result:
                ```(xml)
                    <p><phrase conditions="a,b" id="id11" name="name" xml:lang="en-CA"><annotation type="actor" specifically="John Wayne"><citation idref="cit">The Duke</citation></annotation></phrase> plays Rooster Cogburn.</p>


        case: Attributes on a codeblock

            description:
                Attributes on a codeblock.

            source:
                ```(sam)
                    ```(python)(*id12)(#name)(?a)(?b)
                        def escape_for_xml(s):
                            t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                            try:
                                return s.translate(t)
                            except AttributeError:
                                return s
            markup:
                ```(python)(*id12)(#name)(?a)(?b)
                    def escape_for_xml(s):
                        t = dict(zip([ord('<'), ord('>'), ord('&')], ['&lt;', '&gt;', '&amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s

            result:
                ```(xml)
                    <codeblock conditions="a,b" id="id12" language="python" name="name">
                    def escape_for_xml(s):
                        t = dict(zip([ord('&lt;'), ord('&gt;'), ord('&amp;')], ['&amp;lt;', '&amp;gt;', '&amp;amp;']))
                        try:
                            return s.translate(t)
                        except AttributeError:
                            return s
                    </codeblock>

        case: Attributes on an embed

            description:
                Attributes on a embed.

            source:
                ```(sam)
                    ```(=latexmathml)(*id13)(#name)(?a)(?b)
                        n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            markup:
                ```(=latexmathml)(*id13)(#name)(?a)(?b)
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k

            result:
                ```(xml)
                    <embedblock conditions="a,b" encoding="latexmathml" id="id13" name="name">
                    n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k
                    </embedblock>


        case: Attributes on inserts
            description:
                Attributes on inserts.

            source:
                ```(sam)
                    >>>(image foo.gif)(*id14)(#name)(?a)(?b)

            markup:
                >>>(image foo.gif)(*id14)(#name)(?a)(?b)

            result:
                ```(xml)
                    <insert conditions="a,b" id="id14" item="foo.gif" name="name" type="image"/>

    test: Annotations

        description:

            A phrase can have one or more annotations or citations attached to it.
            On output, the text of the phrase is wrapped in the annotations and
            citations in the order they were specified in source.

        case: Multiple annotations

            description:
                Phrases with more than one attribute in a chain.

            source:
                ```(sam)
                    This is {very}(bold) important.

                    This is {very}(bold)(italic) important.

                    This is {very}(bold)(italic)(green) important.

                    This `foo`(bar) baz.

            markup:
                This is {very}(bold) important.

                This is {very}(bold)(italic) important.

                This is {very}(bold)(italic)(green) important.


            result:
                ```(xml)
                    <p>This is <phrase><annotation type="bold">very</annotation></phrase> important.</p>
                    <p>This is <phrase><annotation type="bold"><annotation type="italic">very</annotation></annotation></phrase> important.</p>
                    <p>This is <phrase><annotation type="bold"><annotation type="italic"><annotation type="green">very</annotation></annotation></annotation></phrase> important.</p>


        case: Consecutive Annotations

            description:
                Two separate annotations with no space between them.

            source:
                ```(sam)
                    {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            markup:
                {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            result:
                ```(xml)
                    <p><phrase><annotation type="actor" specifically="John Wayne"><annotation type="if" specifically="1969">The Duke</annotation></annotation></phrase><phrase><annotation type="actor"><annotation type="if" specifically="2010">Jeff Bridges</annotation></annotation></phrase> plays Rooster Cogburn.</p>

        case: Consecutive Annotations on decorations

            description:
                Two separate annotations with no space between them.

            source:
                ```(sam)
                    {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            markup:
                {The Duke}(actor "John Wayne")(if "1969"){Jeff Bridges}(actor)(if "2010") plays Rooster Cogburn.

            result:
                ```(xml)
                    <p><phrase><annotation type="actor" specifically="John Wayne"><annotation type="if" specifically="1969">The Duke</annotation></annotation></phrase><phrase><annotation type="actor"><annotation type="if" specifically="2010">Jeff Bridges</annotation></annotation></phrase> plays Rooster Cogburn.</p>



        case: Annotation followed by citation

            description:
                Observed in the wild: When an annotated phrase was followed by a
                phrase with a citation, the end of the annotation was not found
                and the two structures were recognized as one long citation.

            source:
                ```(sam)
                    When using the map approach, it is important to
                    think about how your content will {single
                    source}(concept "single sourcing") to paper-like
                    media and hypertext-media. Some people will output
                    the same map to to both media. In hyper-text media
                    that usually results in the map being turned into
                    a table of contents, often displayed in a separate
                    pane as in a help system. This may be fine if you
                    are creating a help system, but it is not how Web
                    content is usually displayed. Another approach to
                    single sourcing content that uses the assemble from
                    pieces approach is to create completely separate maps
                    -- or even to use completely different assembly
                    techniques that don't involve maps at all -- to produce
                    paper-like and hypertext outputs. This can help you
                    to work around some of the design limitations that
                    we talked about in the {single sourcing
                    chapter}[#single_source].

            markup:
                When using the map approach, it is important to
                think about how your content will {single
                source}(concept "single sourcing") to paper-like
                media and hypertext-media. Some people will output
                the same map to to both media. In hyper-text media
                that usually results in the map being turned into
                a table of contents, often displayed in a separate
                pane as in a help system. This may be fine if you
                are creating a help system, but it is not how Web
                content is usually displayed. Another approach to
                single sourcing content that uses the assemble from
                pieces approach is to create completely separate maps
                -- or even to use completely different assembly
                techniques that don't involve maps at all -- to produce
                paper-like and hypertext outputs. This can help you
                to work around some of the design limitations that
                we talked about in the {single sourcing
                chapter}[#single_source].

            result:
                ```(xml)
                    <p>When using the map approach, it is important to think about how your content will <phrase><annotation type="concept" specifically="single sourcing">single source</annotation></phrase> to paper-like media and hypertext-media. Some people will output the same map to to both media. In hyper-text media that usually results in the map being turned into a table of contents, often displayed in a separate pane as in a help system. This may be fine if you are creating a help system, but it is not how Web content is usually displayed. Another approach to single sourcing content that uses the assemble from pieces approach is to create completely separate maps – or even to use completely different assembly techniques that don’t involve maps at all – to produce paper-like and hypertext outputs. This can help you to work around some of the design limitations that we talked about in the <phrase><citation nameref="single_source">single sourcing chapter</citation></phrase>.</p>

        case: Annotation with language metadata
            description:
                You can add language metadata to a phrase.

            source:
                ```(sam)
                    Press {Enter}(key)(!fr-CA)
            markup:
                Press {Enter}(key)(!fr-CA)

            result:
                ```(xml)
                    <p>Press <phrase xml:lang="fr-CA"><annotation type="key">Enter</annotation></phrase></p>

        case: Annotation with a condition
            description:
                You can add condition metadata to a phrase.

            source:
                ```(sam)
                    Press {Enter}(key)(?foo)
            markup:
                Press {Enter}(key)(?foo)

            result:
                ```(xml)
                    <p>Press <phrase conditions="foo"><annotation type="key">Enter</annotation></phrase></p>

        case: Prior annotation lookup

            description:

                If a phrase has no annotation or citation attached to it, the parser will
                attempt to find a suitable annotation by searching back up the document for
                the most recent case of the same phrase. If it finds one, it will copy
                the annotations and citations from that phrase to the current one. This
                prevents writers from having to write the same annotation out over and
                over again. If not prior phrase is found, a warning is issued.


            source:
                ```(sam)
                    This {annotation}(https://en.wikipedia.org/wiki/Annotation) is repeated {annotation}.

            markup:
                This {annotation}(https://en.wikipedia.org/wiki/Annotation) is repeated {annotation}.

            result:
                ```(xml)
                    <p>This <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></phrase> is repeated <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></phrase>.</p>

        case: Case insensitive lookup

            description:

                Annotation lookup is case insensitive unless the annotation-lookup declaration is set to `case sensitive`.


            source:
                ```(sam)
                    This {annotation}(https://en.wikipedia.org/wiki/Annotation) is repeated {Annotation}.

            markup:
                This {annotation}(https://en.wikipedia.org/wiki/Annotation) is repeated {Annotation}.

            result:
                ```(xml)
                    <p>This <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></phrase> is repeated <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">Annotation</annotation></phrase>.</p>

        case: Case insensitive lookup with multiple annotations

            description:

                Make sure all annotations are copied

            source:
                ```(sam)
                    This {annotation}(foo)(https://en.wikipedia.org/wiki/Annotation) is repeated {Annotation}.

            markup:
                This {annotation}(foo)(https://en.wikipedia.org/wiki/Annotation) is repeated {Annotation}.

            result:
                ```(xml)
                    <p>This <phrase><annotation type="foo"><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></annotation></phrase> is repeated <phrase><annotation type="foo"><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">Annotation</annotation></annotation></phrase>.</p>

        case: Prior annotation lookup in included file

            description:
                Look up annotations in included files.

            source:
                ```(sam)
                    Annotation lookup test: {test phrase}.

            markup:
                Annotation lookup test: {test phrase}.


            result:
                ```(xml)
                    <p>Annotation lookup test: <phrase><annotation type="test">test phrase</annotation></phrase>.</p>

        case: Earlier para

            description:
                The marching annotation is in an earlier paragraph in the document. (In this
                case, in the preceding test case).

            source:
                ```(sam)
                    This {annotation} occurs previously.

            markup:
                This {annotation} occurs previously.

            result:
                ```(xml)
                    <p>This <phrase><annotation type="foo"><annotation type="link" specifically="https://en.wikipedia.org/wiki/Annotation">annotation</annotation></annotation></phrase> occurs previously.</p>


        case: Failure
            description:
                There is no previous phrase. This should generate a warning when the test is run.

            source:
                ```(sam)
                    This {should be reported}.

            markup:
                This {should be reported}.

            result:
                ```(xml)
                    <p>This <phrase>should be reported</phrase>.</p>

        case: Local only annotations

            description:
                A local-only annotation is one which applies only to the current phrase.
                It is not taken into consideration in annotation lookup, so the lookup
                search will proceed to the next phrase with the same text. Annotation lookup will
                occur for a phrase with a local-only annotation, and the local annotation will
                be added to the looked up annotations, if any.

            source:
                ```(sam)
                    Testing {XML}(language) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}(language) testing {XML}+(index) testing {XML}.

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="language">XML</annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Attribute annotations
            description:
                Attributes like ID should not be copied because they are supposed to be unique.

            source:
                ```(sam)
                    Testing {XML}+(*foo) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}+(*foo) testing {XML}+(index) testing {XML}.

            result:
                ```(xml)
                    <p>Testing <phrase id="foo"><annotation type="language">XML</annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>

        case: Mix of local and global
            description:
                A mix of local and global annotations. 

            source:
                ```(sam)
                    Testing {XML}+(foo)(language) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}+(foo)(language) testing {XML}+(index) testing {XML}.

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="foo"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>
        case: Multiple local
            description:
                Multiple local annotations. 

            source:
                ```(sam)
                    Testing {XML}+(foobar)+(verbiage) testing {XML}+(index) testing {XML}.

            markup:
                Testing {XML}+(foobar)+(verbiage) testing {XML}+(index) testing {XML}.

            result:
                ```(xml)
                    <p>Testing <phrase><annotation type="foobar"><annotation type="verbiage"><annotation type="language">XML</annotation></annotation></annotation></phrase> testing <phrase><annotation type="index"><annotation type="language">XML</annotation></annotation></phrase> testing <phrase><annotation type="language">XML</annotation></phrase>.</p>
    test: Decorations
        description:
            A decoration is a shortcut for a {media domain}(concept) annotation. Three decorations are supported, bold, italic, and code.

        case: Bold, italic, and code

            description:
                One test case for all decorations.

            source:
                ```(sam)
                    This sentence contains decorations for *bold*, _italic_, and `code`.

            markup:
                This sentence contains decorations for *bold*, _italic_, and `code`.
            
            result:
                ```(xml)
                    <p>This sentence contains decorations for <phrase><annotation type="bold">bold</annotation></phrase>, <phrase><annotation type="italic">italic</annotation></phrase>, and <code>code</code>.</p>

        case: Unbalanced decorations and escapes
            description:
                Unbalanced decorations and escapes
            source:
                ```(sam)
                    In Rio Bravo, \*the \`Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays *an ex-Union colonel `out for revenge.

            markup:
                In Rio Bravo, \*the \`Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays *an ex-Union colonel `out for revenge.

            result:
                ```(xml)
                    <p>In Rio Bravo, *the `Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays *an ex-Union colonel `out for revenge.</p>

    test: Inline code
        description:
            Inline code is a special form of phrase used for phrases that are in computer languages or other encodings other than the human language of the text. 

        case: Inline latexmath

            description:
                A selection of latex math to be printed. 

            source:
                ```(sam)
                    This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(latexmath)(!en) in the middle of a paragraph. 

            markup:
                This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(latexmath)(!en) in the middle of a paragraph. 

            result:
                ```(xml)
                    <p>This is an equation <code language="latexmath" xml:lang="en">\frac{ \sum_{t=0}^{N}f(t,k) }{N}</code> in the middle of a paragraph.</p> 

        case: Embedded latexmath

            description:
                A selection of latex math to be embedded as an equation. 

            source:
                ```(sam)
                    This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(=latexmath) in the middle of a paragraph. 

            markup:
                This is an equation `\frac{ \sum_{t=0}^{N}f(t,k) }{N}`(=latexmath) in the middle of a paragraph. 

            result:
                ```(xml)
                    <p>This is an equation <embed encoding="latexmath">\frac{ \sum_{t=0}^{N}f(t,k) }{N}</embed> in the middle of a paragraph.</p> 




    test: Links

        description:

            Links are created with an annotation.

            You can specify a link as a `link` annotation.

            ```
                foo {bar}(link "http://example.com/bar") baz

            The link annotation shortcut lets you shorten this to:

            ```
                foo {bar}(http://example.com/bar) baz

            However, use of the shortcut means you need to escape
            any parens that occur in the URL.


        case: Parens not escaped

            description:
                The parens are not escaped, causing misreading of markup. This example
                should be interpreted incorrectly.


            source:
                ```(sam)
                    Rio Bravo refers to the movie
                    (and not to {the city in Texas or
                    the nature reserve in
                    Belize}(https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)))

            markup:
                Rio Bravo refers to the movie
                (and not to {the city in Texas or
                the nature reserve in
                Belize}(https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)))

            result:
                ```(xml)
                    <p>Rio Bravo refers to the movie (and not to <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_" namespace="disambiguation">the city in Texas or the nature reserve in Belize</annotation></phrase>)</p>


        case: Parens escaped with backslashes

            description:
                The parens in the URL are escaped with blackslashes. This example
                should be interpreted correctly.

            source:
                ```(sam)
                    Rio Bravo refers to the movie
                    (and not to {the city in Texas or
                    the nature reserve in
                    Belize}(https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_\(disambiguation\)))

            markup:
                Rio Bravo refers to the movie
                (and not to {the city in Texas or
                the nature reserve in
                Belize}(https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_\(disambiguation\)))

            result:
                ```(xml)
                    <p>Rio Bravo refers to the movie (and not to <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)">the city in Texas or the nature reserve in Belize</annotation></phrase>)</p>

        case: Using explicit link annotation instead of shortcut

            description:
                The link is specified using a specific link annotation so the
                URL is not in parens itself. This example should be interpreted
                correctly.

            source:
                ```(sam)
                    Rio Bravo refers to the movie
                    (and not to {the city in Texas or
                    the nature reserve in
                    Belize}(link "https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)"))

            markup:
                Rio Bravo refers to the movie
                (and not to {the city in Texas or
                the nature reserve in
                Belize}(link "https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)"))

            result:
                ```(xml)
                    <p>Rio Bravo refers to the movie (and not to <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_(disambiguation)">the city in Texas or the nature reserve in Belize</annotation></phrase>)</p>

    test: Citations

        description:
            A citation is a reference to a source of information. You
            can cite with a phrase or by reference to an ID or a name.

        case: Citation on phrase

            description:
                A citation on a phrase

            source:
                ```(SAM)
                    You can {call me Ishmael}[Melville, 1851][Daffy, 2017].

            markup:
                You can {call me Ishmael}[Melville, 1851][Daffy, 2017].

            result:
                ```(XML)
                    <p>You can <phrase><citation value="Melville, 1851"><citation value="Daffy, 2017">call me Ishmael</citation></citation></phrase>.</p>

        case: Citation and annotation on one phrase

            description:
                A citation on a phrase that also has an annotation.

            source:
                ```(SAM)
                    You can {call me Ishmael}(quote)[Melville, 1851].

            markup:
                You can {call me Ishmael}(quote)[Melville, 1851].

            result:
                ```(XML)
                    <p>You can <phrase><annotation type="quote"><citation value="Melville, 1851">call me Ishmael</citation></annotation></phrase>.</p>

        case: Literal square brackets
            description:
                If you want to enter literal square brackets, rather than create a citation,
                escape the opening square bracket with a backslash.

            source:
                ```(sam)
                    Press \[Enter].

            markup:
                Press \[Enter].

            result:
                ```(xml)
                    <p>Press [Enter].</p>

        case: Multiple citations is a paragraph

            description:
                 Making sure that when there are multiple citations in a paragraph they are all detected separately.

            source:
                 ```(sam)
                    Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in [#chapter.linking] and the subject-based composition and architecture algorithms described in [#chapter.composition] and [#chapter.architecture], including bottom-up information architecture.

            markup:
                Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in [#chapter.linking] and the subject-based composition and architecture algorithms described in [#chapter.composition] and [#chapter.architecture], including bottom-up information architecture.

            result:
                ```(xml)
                    <p>Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in <citation nameref="chapter.linking"/> and the subject-based composition and architecture algorithms described in <citation nameref="chapter.composition"/> and <citation nameref="chapter.architecture"/>, including bottom-up information architecture.</p>

    test: Characters

        description:

            All SAM documents are UTF-8 unicode documents. Therefore you should
            be able to enter any character directly. However, typing extended
            characters is not easy, so SAM supports character entities for
            entering characters that are not easy to type.

        case: HTML named entities

            description:

                All of the HTML named character entities are supported.

            source:
                ```(sam)
                    The doggy in the window costs &pound;5.00.

            markup:
                The doggy in the window costs &pound;5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs £5.00.</p>




        case: Numeric entities

            description:

                XML-style decimal numeric character entities are supported.

            source:
                ```(sam)
                    The doggy in the window costs &#163;5.00.

            markup:
                The doggy in the window costs &#163;5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs £5.00.</p>


        case: Hexadecimal entity

            description:

                XML-style hexadecimal numeric character entities are supported.

            source:
                ```(sam)
                    The doggy in the window costs &#xA3;5.00.

            markup:
                The doggy in the window costs &#xA3;5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs £5.00.</p>

        case: Character entities inside phrases and decorations

            description:
                Make sure entities are recognized in phrases and
                decorations.

            source:
                ```(sam)
                    The doggy in the window costs *&#xA3;*5.00.

                    The doggy in the window costs {&#xA3;5.00}(money).

            markup:
                The doggy in the window costs *&#xA3;*5.00.

                The doggy in the window costs {&#xA3;5.00}(money).

            result:
                ```(xml)
                    <p>The doggy in the window costs <phrase><annotation type="bold">£</annotation></phrase>5.00.</p>
                    <p>The doggy in the window costs <phrase><annotation type="money">£5.00</annotation></phrase>.</p>


        case: In code annotation shortcut:

            description:

                In a code decoration, character entities are not expanded.

            source:
                ```(sam)
                    The doggy in the window costs `&#xA3;`5.00.

            markup:
                The doggy in the window costs `&#xA3;`5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs <code>&amp;#xA3;</code>5.00.</p>



        case: In bold decoration escaped:

            description:
                Escaped version inside a bold decoration.

            source:
                ```(sam)
                    The doggy in the window costs *\&#xA3;*5.00.

            markup:
                The doggy in the window costs *\&#xA3;*5.00.

            result:
                ```(xml)
                    <p>The doggy in the window costs <phrase><annotation type="bold">&amp;#xA3;</annotation></phrase>5.00.</p>


        case: Ampersand in a sentence, escaped with \ and not escaped.

            description:

                Unlike XML, SAM does not require that an ampersand be escaped if it is not part of a character entity. You
                can escape it if you want to using a backslash. Both should output in XML as `&amp;`

            source:
                ```(sam)
                    The cat & the dog.

                    The cat \& the dog.

            markup:
                The cat & the dog.

                The cat \& the dog.

            result:
                ```(xml)
                    <p>The cat &amp; the dog.</p>
                    <p>The cat &amp; the dog.</p>

    test: Character escapes

        description:
            Character escaping



        case: Escapes in explicit annotations

            description:
                Escaping curly braces and backslashes inside a phrase.

            source:
                ```(sam)
                    There is a curly brace and two backslashes in {this \\\\\{ phrase}(bold).

            markup:
                There is a curly brace and two backslashes in {this \\\\\{ phrase}(bold).

            result:
                ```(xml)
                    <p>There is a curly brace and two backslashes in <phrase><annotation type="bold">this \\{ phrase</annotation></phrase>.</p>

        case: Escapes in code decorations

            description:
                Code decorations have different escaping rules. All characters are literal
                except that the backtick character can be escaped with a double back tick.
                Character entities are not translated in a code decoration. Smart quote
                transformations are not applied.

            source:
                ```(sam)
                    There is a backtick and two backslashes in `th\\is `` code` decoration.

                    There is a backslash and a curly brace in `this \{ code` decoration.

                    `pubwork="book"` is an attribute on the element `citetitle`.

            markup:
                There is a backtick and two backslashes in `th\\is `` code` decoration.

                There is a backslash and a curly brace in `this \{ code` decoration.

                `pubwork="book"` is an attribute on the element `citetitle`.

            result:
                ```(xml)
                    <p>There is a backtick and two backslashes in <code>th\\is ` code</code> decoration.</p>
                    <p>There is a backslash and a curly brace in <code>this \{ code</code> decoration.</p>
                    <p><code>pubwork="book"</code> is an attribute on the element <code>citetitle</code>.</p>



        case: Escapes in decorations

            description:

                Escape sequences are recognized inside decorations.

            source:
                ```(sam)
                    There is a `*` in *this \* bold* decoration.

                    There is a `_` in _this \_ italic_ decoration.

            markup:
                There is a `*` in *this \* bold* decoration.

                There is a `_` in _this \_ italic_ decoration.

            result:
                ```(xml)
                    <p>There is a <code>*</code> in <phrase><annotation type="bold">this * bold</annotation></phrase> decoration.</p>
                    <p>There is a <code>_</code> in <phrase><annotation type="italic">this _ italic</annotation></phrase> decoration.</p>

        case: XML reserved characters in citation specifically attribute

            description:
                XML reserved characters occurring within the text of a "specifically" attribute.

            source:
                ```(sam)
                    {Skimbleshanks}(animal '"Old  <>& Possum"' (Eliott)).

            markup:
                {Skimbleshanks}(animal '"Old  <>& Possum"' (Eliott)).

            result:
                ```(xml)
                    <p><phrase><annotation type="animal" specifically="&quot;Old  &lt;&gt;&amp; Possum&quot;" namespace="Eliott">Skimbleshanks</annotation></phrase>.</p>

    test: Conditions

        description:

            You can add conditions to block metadata using condition tokens.
            Condition tokens start with `?` and must not contain spaces. The
            application of conditions to text is up to the application layer.
            SAM just provided a mechanism for recording conditions.

        case: Conditions on unordered list shortcut

            description:

                A condition on an unordered list item.

            source:
                ```(sam)
                    * Fred

                    *(?foo) Barney and
                            Betty and
                            Bam Bam.

                    * Wilma

            markup:

                * Fred

                *(?foo) Barney and
                        Betty and
                        Bam Bam.

                * Wilma

            result:
                ```(xml)
                    <ul>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="foo">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ul>

        case: Conditions on ordered list shortcut
            description:
                Condition on an ordered list item.

            source:
                ```(sam)
                    1. Fred
                    2.(?foo) Barney and
                             Betty and
                             Bam Bam.
                    3. Wilma

            markup:
                1. Fred
                2.(?foo) Barney and
                         Betty and
                         Bam Bam.
                3. Wilma

            result:
                ```(xml)
                    <ol>
                    <li>
                    <p>Fred</p>
                    </li>
                    <li conditions="foo">
                    <p>Barney and Betty and Bam Bam.</p>
                    </li>
                    <li>
                    <p>Wilma</p>
                    </li>
                    </ol>

    test: Block inserts

        description:

            An insert creates an instruction to insert something into the document.

        case: Image insert
            description:
                Insert an image.

            source:
                ```(sam)
                    >>>(image foo.gif)(?goo)

            markup:
                >>>(image foo.gif)(?goo)

            result:
                ```(xml)
                    <insert conditions="goo" item="foo.gif" type="image"/>

        case: Key insert
            description:
                Insert the value of a key. Syntax for creating keys is left to the language designer.
                Key resolution belongs to the application layer.

            source:
                ```(sam)
                    >>>(%glug)

            markup:
                >>>(%glug)

            result:
                ```(xml)
                    <insert item="glug" type="key"/>

    test: Inline inserts

        description:
            Inline inserts are an instructions to insert something into the middle of a paragraph.

        case: Inline inserts
            description:
                Inline inserts.

            source:
                ```(sam)
                    Because you often want to >(image "foo.gif")(#bar)(?baz)(?bat) change some part of a text when it is being
                    reused, <fragments> & fragment references can both define local {strings}(feature).
                    Any {string references}(feature) inside a fragment will be resolved by looking first
                    at local-strings defined in the >(*my-table) fragment reference, then at local strings defined
                    in the fragment definition, and then at global strings. In effect, this means
                    that you can define string substitutions whenever you insert a fragment into your content.

            markup:

                Because you often want to >(image "foo.gif")(#bar)(?baz)(?bat) change some part of a text when it is being
                reused, <fragments> & fragment references can both define local {strings}(feature).
                Any {string references}(feature) inside a fragment will be resolved by looking first
                at local-strings defined in the >(*my-table) fragment reference, then at local strings defined
                in the fragment definition, and then at global strings. In effect, this means
                that you can define string substitutions whenever you insert a fragment into your content.

            result:
                ```(xml)
                    <p>Because you often want to <inline-insert conditions="baz,bat" item="foo.gif" name="bar" type="image"/> change some part of a text when it is being reused, &lt;fragments&gt; &amp; fragment references can both define local <phrase><annotation type="feature">strings</annotation></phrase>. Any <phrase><annotation type="feature">string references</annotation></phrase> inside a fragment will be resolved by looking first at local-strings defined in the <inline-insert item="my-table" type="id"/> fragment reference, then at local strings defined in the fragment definition, and then at global strings. In effect, this means that you can define string substitutions whenever you insert a fragment into your content.</p>

        case: Paragraph that is just an inline insert
            description:
                An inline insert on a line by itself creates a paragraph containing an insert, rather
                than a standalone insert instruction.

            source:
                ```(sam)
                    >(#foo)

            markup:
                >(#foo)

            result:
                ```(xml)
                    <p><inline-insert item="foo" type="name"/></p>

    test: Strings

        description:
            A string is a variable that can contain text, including annotations and citations.

        case: String definition
            description:
                A string definition.

            source:
                ```(sam)
                    $foo = bar bar black sheep

            markup:
                $foo = bar bar black sheep

            result:
                ```(xml)
                    <string name="foo">bar bar black sheep</string>

        case: String references
            description:
                Inserting the value of a string.

            source:
                ```(sam)
                    This sentence includes a string reference >(string name). And a shortcut version >($name).

            markup:
                This sentence includes a string reference >(string name). And a shortcut version >($name).

            result:
                ```(xml)
                   <p>This sentence includes a string reference <inline-insert item="name" type="string"/>. And a shortcut version <inline-insert item="name" type="string"/>.</p>

    test: Fragments
        description:
            Fragments are sequences of paragraphs that can have management metadata applied to them
            and that can be inserted in other places.

        case: Fragment
            description:
                A fragment definition.

            source:
                ```(sam)
                    ~~~(#foo3)(?gruz-natz)
                        $a=apple
                        $b=banana

                        This is a sentence inside a fragment.

                        ~~~(#gruznatz)
                            $p=peach

                            This is a nested fragment.

            markup:
                ~~~(#foo3)(?gruz-natz)
                    $a=apple
                    $b=banana

                    This is a sentence inside a fragment.

                    ~~~(#gruznatz)
                        $p=peach

                        This is a nested fragment.

            result:
                ```(xml)
                    <fragment conditions="gruz-natz" name="foo3">
                    <string name="a">apple</string>
                    <string name="b">banana</string>
                    <p>This is a sentence inside a fragment.</p>
                    <fragment name="gruznatz">
                    <string name="p">peach</string>
                    <p>This is a nested fragment.</p>
                    </fragment>
                    </fragment>

        case: Insert a fragment

            description:
                An instruction to insert a fragment. Note that actually resolving an inserting
                the fragment is a job for the application layer.

            source:
                ```(sam)
                    >>>(~foobar)
                        $a=apricot
                        $b=breadfruit

            markup:
                >>>(~foobar)
                    $a=apricot
                    $b=breadfruit

            result:
                ```(xml)
                    <insert item="foobar" type="fragment">
                    <string name="a">apricot</string>
                    <string name="b">breadfruit</string>
                    </insert>



    test: Smart quotes

        description:
            Smart quotes is an optional feature of the parser, not a
            feature of the SAM language. It turns straight quotes into
            curly quotes. It raises a warning when it can't figure out
            how to handle a case. The algorithm could be improved in
            the future to handle more cases correctly.

            The canonical way to handle quotes in SAM is to use real
            curly quotes to begin with. All SAM documents are UTF-8.

            Note: These tests will fail if smart quotes is not selected
            using the `-q` option of the parser command line or by
            setting the `smart_quotes` attribute of the SamParser
            object to `True`.

        case: Smart quotes

            description:

                Paragraphs illustrating most of the cases where smart quotes should
                be recognized in ordinary English.

            source:
                ```(sam)
                    "For once, 'sir' adding, 'you're making a
                    scene.'" and "For once, 'sir' adding,
                    'you're making a scene.'" In the winter
                    of ’65. "Yes," he said, "I met her. She's
                    very 'friendly.'" '"I don’t know what you
                    mean by 'glory,'" Alice said.' "'I don’t
                    know what you mean by "glory,"' Alice said."

                    For "the Duke", perhaps?

            markup:
                "For once, 'sir' adding, 'you're making a
                scene.'" and "For once, 'sir' adding,
                'you're making a scene.'" In the winter
                of ’65. "Yes," he said, "I met her. She's
                very 'friendly.'" '"I don’t know what you
                mean by 'glory,'" Alice said.' "'I don’t
                know what you mean by "glory,"' Alice said."

                For "the Duke", perhaps?

            result:
                ```(xml)
                    <p>“For once, ‘sir’ adding, ‘you’re making a scene.’” and “For once, ‘sir’ adding, ‘you’re making a scene.’” In the winter of ’65. “Yes,” he said, “I met her. She’s very ‘friendly.’” ‘“I don’t know what you mean by ‘glory,’” Alice said.’ “‘I don’t know what you mean by “glory,”’ Alice said.”</p>
                    <p>For “the Duke”, perhaps?</p>

        case: Following an annotation

            description:
                Smart quotes also need to be recognized when they follow
                SAM markup.

            source:
                ```(sam)

                    interpretations of the `xref`'s instruction

            markup:
                interpretations of the `xref`'s instruction

            result:
                ```(xml)
                    <p>interpretations of the <code>xref</code>’s instruction</p>

        case: Smart quotes with annotations

            description:

                Smart quotes surrounding annotated phrases.

            source:
                ```(sam)
                    "For once, '{sir}(salutation)' adding, 'you're making a
                    scene.'" and "For once, {'sir'}(salutation) adding,
                    'you're making a scene.'" In the winter
                    of ’65. "Yes," he said, "I met her. She's
                    very 'friendly.'" '"I don’t know what you
                    mean by 'glory,'" Alice said.' "'I don’t
                    know what you mean by "glory,"' Alice said."

            markup:
                "For once, '{sir}(salutation)' adding, 'you're making a
                scene.'" and "For once, {'sir'}(salutation) adding,
                'you're making a scene.'" In the winter
                of ’65. "Yes," he said, "I met her. She's
                very 'friendly.'" '"I don’t know what you
                mean by 'glory,'" Alice said.' "'I don’t
                know what you mean by "glory,"' Alice said."

            result:
                ```(xml)
                    <p>“For once, ‘<phrase><annotation type="salutation">sir</annotation></phrase>’ adding, ‘you’re making a scene.’” and “For once, <phrase><annotation type="salutation">‘sir’</annotation></phrase> adding, ‘you’re making a scene.’” In the winter of ’65. “Yes,” he said, “I met her. She’s very ‘friendly.’” ‘“I don’t know what you mean by ‘glory,’” Alice said.’ “‘I don’t know what you mean by “glory,”’ Alice said.”</p>

        case: Adjacent to parentheses
            description:
                Quotes inside parentheses.

            source:
                ```(sam)
                    A vector graphic program creates graphics as a collection of  objects ("vector" meaning the mathematical representation of a shape or line).

                    The shape of the characters (technically, "glyphs") that make up the font are stored separately in font files.

            markup:
                A vector graphic program creates graphics as a collection of  objects ("vector" meaning the mathematical representation of a shape or line).

                The shape of the characters (technically, "glyphs") that make up the font are stored separately in font files.

            result:
                ```(xml)
                    <p>A vector graphic program creates graphics as a collection of  objects (“vector” meaning the mathematical representation of a shape or line).</p>
                    <p>The shape of the characters (technically, “glyphs”) that make up the font are stored separately in font files.</p>


        case: Close quote followed by citation.
            description:
                Close quote followed by citation.

            source:
                ```(sam)
                    "What is truth?"[John 18:38]

            markup:
                "What is truth?"[John 18:38]

            result:
                ```(xml)
                    <p>“What is truth?”<citation value="John 18:38"/></p>

        case: Miscellaneous cases

            description:
                A bunch of miscellaneous cases.


            source:
                ```(sam)
                    "title"?

                    {DocBook}(language)'s

                    {DITA}(language) and {DocBook}'s

            markup:
                "title"?

                {DocBook}(language)'s

                {DITA}(language) and {DocBook}'s

            result:
                ```(xml)
                    <p>“title”?</p>
                    <p><phrase><annotation type="language">DocBook</annotation></phrase>’s</p>
                    <p><phrase><annotation type="language">DITA</annotation></phrase> and <phrase><annotation type="language">DocBook</annotation></phrase>’s</p>




        case: Escaped dumb quotes
            description:
                If you want to enter straight quotes and have them stay straight when
                smart quotes are applied, you have to escape them with `\` or use the
                `&quot;` character entity.

            source:
                ```(sam)
                    This para uses \"dumb\" quotes. Don\'t get them &quot;mixed up&quot;.

            markup:
                This para uses \"dumb\" quotes. Don\'t get them &quot;mixed up&quot;.

            result:
                ```(xml)
                    <p>This para uses "dumb" quotes. Don't get them "mixed up".</p>

        case: Em and en dashes
            description:
                The smart quote feature will also transform double hyphens surrounded
                by spaces and triple hyphens surrounded by letters into en and em
                dashes respectively.

            source:
                ```(sam)
                    This para contains -- an en dash and an---em dash.

                    This para contains -- {an}(word) en dash and an---{em}(word) dash.

                    This para {contains}(word) -- an en dash and {an}(word)---em dash.

                    This para *contains* -- an en dash and _an_---em dash.

                    This para `contains` -- an en dash and "an"---em dash.

                    This para 'contains' -- an en dash and `an`---em dash.

                    x, y, z, etc. -- something else

            markup:
                This para contains -- an en dash and an---em dash.

                This para contains -- {an}(word) en dash and an---{em}(word) dash.

                This para {contains}(word) -- an en dash and {an}(word)---em dash.

                This para *contains* -- an en dash and _an_---em dash.

                This para `contains` -- an en dash and "an"---em dash.

                This para 'contains' -- an en dash and `an`---em dash.

                x, y, z, etc. -- something else

            result:
                ```(xml)
                    <p>This para contains – an en dash and an—em dash.</p>
                    <p>This para contains – <phrase><annotation type="word">an</annotation></phrase> en dash and an—<phrase><annotation type="word">em</annotation></phrase> dash.</p>
                    <p>This para <phrase><annotation type="word">contains</annotation></phrase> – an en dash and <phrase><annotation type="word">an</annotation></phrase>—em dash.</p>
                    <p>This para <phrase><annotation type="bold">contains</annotation></phrase> – an en dash and <phrase><annotation type="italic">an</annotation></phrase>—em dash.</p>
                    <p>This para <code>contains</code> – an en dash and “an”—em dash.</p>
                    <p>This para ‘contains’ – an en dash and <code>an</code>—em dash.</p>
                    <p>x, y, z, etc. – something else</p>

# Can we have comments after the end of the document?
# Yes we can!
